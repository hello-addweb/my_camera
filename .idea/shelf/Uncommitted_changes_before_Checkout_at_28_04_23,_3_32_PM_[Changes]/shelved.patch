Index: example/pubspec.lock
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+># Generated by pub\n# See https://dart.dev/tools/pub/glossary#lockfile\npackages:\n  async:\n    dependency: transitive\n    description:\n      name: async\n      sha256: bfe67ef28df125b7dddcea62755991f807aa39a2492a23e1550161692950bbe0\n      url: \"https://pub.dev\"\n    source: hosted\n    version: \"2.10.0\"\n  boolean_selector:\n    dependency: transitive\n    description:\n      name: boolean_selector\n      sha256: \"6cfb5af12253eaf2b368f07bacc5a80d1301a071c73360d746b7f2e32d762c66\"\n      url: \"https://pub.dev\"\n    source: hosted\n    version: \"2.1.1\"\n  characters:\n    dependency: transitive\n    description:\n      name: characters\n      sha256: e6a326c8af69605aec75ed6c187d06b349707a27fbff8222ca9cc2cff167975c\n      url: \"https://pub.dev\"\n    source: hosted\n    version: \"1.2.1\"\n  clock:\n    dependency: transitive\n    description:\n      name: clock\n      sha256: cb6d7f03e1de671e34607e909a7213e31d7752be4fb66a86d29fe1eb14bfb5cf\n      url: \"https://pub.dev\"\n    source: hosted\n    version: \"1.1.1\"\n  collection:\n    dependency: transitive\n    description:\n      name: collection\n      sha256: cfc915e6923fe5ce6e153b0723c753045de46de1b4d63771530504004a45fae0\n      url: \"https://pub.dev\"\n    source: hosted\n    version: \"1.17.0\"\n  cupertino_icons:\n    dependency: \"direct main\"\n    description:\n      name: cupertino_icons\n      sha256: e35129dc44c9118cee2a5603506d823bab99c68393879edb440e0090d07586be\n      url: \"https://pub.dev\"\n    source: hosted\n    version: \"1.0.5\"\n  custom_camera:\n    dependency: \"direct main\"\n    description:\n      path: \"..\"\n      relative: true\n    source: path\n    version: \"0.0.4-nullsafety\"\n  fake_async:\n    dependency: transitive\n    description:\n      name: fake_async\n      sha256: \"511392330127add0b769b75a987850d136345d9227c6b94c96a04cf4a391bf78\"\n      url: \"https://pub.dev\"\n    source: hosted\n    version: \"1.3.1\"\n  flutter:\n    dependency: \"direct main\"\n    description: flutter\n    source: sdk\n    version: \"0.0.0\"\n  flutter_test:\n    dependency: \"direct dev\"\n    description: flutter\n    source: sdk\n    version: \"0.0.0\"\n  js:\n    dependency: transitive\n    description:\n      name: js\n      sha256: \"5528c2f391ededb7775ec1daa69e65a2d61276f7552de2b5f7b8d34ee9fd4ab7\"\n      url: \"https://pub.dev\"\n    source: hosted\n    version: \"0.6.5\"\n  matcher:\n    dependency: transitive\n    description:\n      name: matcher\n      sha256: \"16db949ceee371e9b99d22f88fa3a73c4e59fd0afed0bd25fc336eb76c198b72\"\n      url: \"https://pub.dev\"\n    source: hosted\n    version: \"0.12.13\"\n  material_color_utilities:\n    dependency: transitive\n    description:\n      name: material_color_utilities\n      sha256: d92141dc6fe1dad30722f9aa826c7fbc896d021d792f80678280601aff8cf724\n      url: \"https://pub.dev\"\n    source: hosted\n    version: \"0.2.0\"\n  meta:\n    dependency: transitive\n    description:\n      name: meta\n      sha256: \"6c268b42ed578a53088d834796959e4a1814b5e9e164f147f580a386e5decf42\"\n      url: \"https://pub.dev\"\n    source: hosted\n    version: \"1.8.0\"\n  path:\n    dependency: transitive\n    description:\n      name: path\n      sha256: db9d4f58c908a4ba5953fcee2ae317c94889433e5024c27ce74a37f94267945b\n      url: \"https://pub.dev\"\n    source: hosted\n    version: \"1.8.2\"\n  sky_engine:\n    dependency: transitive\n    description: flutter\n    source: sdk\n    version: \"0.0.99\"\n  source_span:\n    dependency: transitive\n    description:\n      name: source_span\n      sha256: dd904f795d4b4f3b870833847c461801f6750a9fa8e61ea5ac53f9422b31f250\n      url: \"https://pub.dev\"\n    source: hosted\n    version: \"1.9.1\"\n  stack_trace:\n    dependency: transitive\n    description:\n      name: stack_trace\n      sha256: c3c7d8edb15bee7f0f74debd4b9c5f3c2ea86766fe4178eb2a18eb30a0bdaed5\n      url: \"https://pub.dev\"\n    source: hosted\n    version: \"1.11.0\"\n  stream_channel:\n    dependency: transitive\n    description:\n      name: stream_channel\n      sha256: \"83615bee9045c1d322bbbd1ba209b7a749c2cbcdcb3fdd1df8eb488b3279c1c8\"\n      url: \"https://pub.dev\"\n    source: hosted\n    version: \"2.1.1\"\n  string_scanner:\n    dependency: transitive\n    description:\n      name: string_scanner\n      sha256: \"556692adab6cfa87322a115640c11f13cb77b3f076ddcc5d6ae3c20242bedcde\"\n      url: \"https://pub.dev\"\n    source: hosted\n    version: \"1.2.0\"\n  term_glyph:\n    dependency: transitive\n    description:\n      name: term_glyph\n      sha256: a29248a84fbb7c79282b40b8c72a1209db169a2e0542bce341da992fe1bc7e84\n      url: \"https://pub.dev\"\n    source: hosted\n    version: \"1.2.1\"\n  test_api:\n    dependency: transitive\n    description:\n      name: test_api\n      sha256: ad540f65f92caa91bf21dfc8ffb8c589d6e4dc0c2267818b4cc2792857706206\n      url: \"https://pub.dev\"\n    source: hosted\n    version: \"0.4.16\"\n  vector_math:\n    dependency: transitive\n    description:\n      name: vector_math\n      sha256: \"80b3257d1492ce4d091729e3a67a60407d227c27241d6927be0130c98e741803\"\n      url: \"https://pub.dev\"\n    source: hosted\n    version: \"2.1.4\"\nsdks:\n  dart: \">=2.19.5 <3.0.0\"\n  flutter: \">=1.20.0\"\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/example/pubspec.lock b/example/pubspec.lock
--- a/example/pubspec.lock	
+++ b/example/pubspec.lock	
@@ -55,7 +55,7 @@
       path: ".."
       relative: true
     source: path
-    version: "0.0.4-nullsafety"
+    version: "0.0.2"
   fake_async:
     dependency: transitive
     description:
Index: pubspec.yaml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>name: custom_camera\ndescription: A new Flutter Camera plugin, which gives more functionality of Scanner and OCR.\nversion: 0.0.2-nullsafety\nhomepage: https://github.com/hello-addweb/my_camera.git\n\nenvironment:\n  sdk: \">=2.19.5 <3.0.0\"\n  flutter: \">=1.20.0 <2.0.0\"\n\ndependencies:\n  flutter:\n    sdk: flutter\n\ndev_dependencies:\n  flutter_test:\n    sdk: flutter\n\n# For information on the generic Dart part of this file, see the\n# following page: https://dart.dev/tools/pub/pubspec\n\n# The following section is specific to Flutter.\nflutter:\n  # This section identifies this Flutter project as a plugin project.\n  # The 'pluginClass' and Android 'package' identifiers should not ordinarily\n  # be modified. They are used by the tooling to maintain consistency when\n  # adding or updating assets for this project.\n  plugin:\n    platforms:\n      android:\n        package: com.search.my_camera\n        pluginClass: MyCameraPlugin\n      ios:\n        pluginClass: MyCameraPlugin\n\n\n  # To add assets to your plugin package, add an assets section, like this:\n  # assets:\n  #   - images/a_dot_burr.jpeg\n  #   - images/a_dot_ham.jpeg\n  #\n  # For details regarding assets in packages, see\n  # https://flutter.dev/assets-and-images/#from-packages\n  #\n  # An image asset can refer to one or more resolution-specific \"variants\", see\n  # https://flutter.dev/assets-and-images/#resolution-aware.\n\n  # To add custom fonts to your plugin package, add a fonts section here,\n  # in this \"flutter\" section. Each entry in this list should have a\n  # \"family\" key with the font family name, and a \"fonts\" key with a\n  # list giving the asset and other descriptors for the font. For\n  # example:\n  # fonts:\n  #   - family: Schyler\n  #     fonts:\n  #       - asset: fonts/Schyler-Regular.ttf\n  #       - asset: fonts/Schyler-Italic.ttf\n  #         style: italic\n  #   - family: Trajan Pro\n  #     fonts:\n  #       - asset: fonts/TrajanPro.ttf\n  #       - asset: fonts/TrajanPro_Bold.ttf\n  #         weight: 700\n  #\n  # For details regarding fonts in packages, see\n  # https://flutter.dev/custom-fonts/#from-packages\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/pubspec.yaml b/pubspec.yaml
--- a/pubspec.yaml	
+++ b/pubspec.yaml	
@@ -1,11 +1,11 @@
 name: custom_camera
 description: A new Flutter Camera plugin, which gives more functionality of Scanner and OCR.
-version: 0.0.2-nullsafety
+version: 0.0.2
 homepage: https://github.com/hello-addweb/my_camera.git
 
 environment:
   sdk: ">=2.19.5 <3.0.0"
-  flutter: ">=1.20.0 <2.0.0"
+  flutter: ">=1.20.0"
 
 dependencies:
   flutter:
@@ -14,6 +14,7 @@
 dev_dependencies:
   flutter_test:
     sdk: flutter
+  test: ^1.22.0
 
 # For information on the generic Dart part of this file, see the
 # following page: https://dart.dev/tools/pub/pubspec
Index: example/lib/main.dart
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import 'dart:async';\nimport 'dart:io';\nimport 'dart:typed_data';\n\nimport 'package:custom_camera/my_cameranew.dart';\nimport 'package:flutter/cupertino.dart';\nimport 'package:flutter/material.dart';\n\nimport 'new.dart';\n\nvoid main() {\n  String id = DateTime.now().toIso8601String();\n  runApp(MaterialApp(\n    debugShowCheckedModeBanner: false,\n      home: MyApp(id: id)));\n}\n\nclass MyApp extends StatefulWidget {\n  final String? id;\n\n  const MyApp({Key? key, this.id}) : super(key: key);\n\n  @override\n  _MyAppState createState() => _MyAppState();\n}\n\nclass _MyAppState extends State<MyApp> {\n  List<String> pictureSizes = [];\n  String? imagePath;\n  Uint8List bytes = Uint8List(0);\n\n  late TextEditingController outputController;\n  late MyCameraController cameraController;\n\n  @override\n  initState() {\n    super.initState();\n    this.outputController = new TextEditingController();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('Home'),\n      ),\n      body: SafeArea(\n        child: Stack(\n          children: [\n            Column(\n              children: [\n                /// Ui container\n                Container(\n                  color: Colors.transparent,\n                  child: Row(\n                    children: [\n                      /// Scanning Photo flashLight on or off\n                      IconButton(\n                        icon: Icon(\n                          Icons.flash_off_outlined,\n                          color: Colors.black,\n                        ),\n                        onPressed: () {\n                          cameraController.setFlashType(FlashType.off);\n                        },\n                      ),\n                      IconButton(\n                        icon: Icon(\n                          Icons.flash_on,\n                          color: Colors.black,\n                        ),\n                        onPressed: () {\n                          cameraController.setFlashType(FlashType.torch);\n                        },\n                      ),\n                    ],\n                  ),\n                ),\n                /// The barcode or qrcode you scan will be displayed\n                TextField(\n                  controller: this.outputController,\n                  maxLines: 2,\n                  decoration: InputDecoration(\n                    prefixIcon: Icon(Icons.wrap_text),\n                    hintText:\n                        'The barcode or qrcode you scan will be displayed in this area.',\n                    hintStyle: TextStyle(fontSize: 15),\n                    contentPadding:\n                        EdgeInsets.symmetric(horizontal: 7, vertical: 15),\n                  ),\n                ),\n                /// Image Capture in camra\n                Expanded(\n                    child: Container(\n                  child: MyCamera(\n                    onCameraCreated: _onCameraCreated,\n                    onImageCaptured: (String path) {\n                      print(\"onImageCaptured => \" + path);\n                      if (this.mounted)\n                        setState(() {\n                          imagePath = path;\n                        });\n                    },\n                    cameraPreviewRatio: CameraPreviewRatio.r16_9,\n                  ),\n                )),\n              ],\n            ),\n            Positioned(\n              bottom: 16.0,\n              left: 16.0,\n              child: imagePath != null\n                  ? Container(\n                      width: 100.0,\n                      height: 100.0,\n                      child: Image.file(File(imagePath!)))\n                  : Icon(Icons.image),\n            )\n          ],\n        ),\n      ),\n      floatingActionButton: Column(\n          crossAxisAlignment: CrossAxisAlignment.end,\n          mainAxisSize: MainAxisSize.min,\n          children: [\n            FloatingActionButton(\n              heroTag: 1,\n              child: Icon(Icons.switch_camera),\n              onPressed: () async {\n                await cameraController.switchCamera();\n              },\n            ),\n            Container(height: 16.0),\n            FloatingActionButton(\n                heroTag: 2,\n                child: Icon(Icons.camera_alt),\n                onPressed: () {\n                  cameraController.captureImage();\n                }),\n            Container(height: 16.0),\n            FloatingActionButton(\n                heroTag: 3,\n                child: Icon(Icons.scanner),\n                onPressed: () {\n                  _scan();\n                }),\n            Container(height: 16.0),\n            FloatingActionButton(\n                heroTag: 4,\n                child: Icon(Icons.chrome_reader_mode),\n                onPressed: () {\n                  _navigation();\n                }),\n          ]),\n    );\n  }\n\n  Future _scan() async {\n    String barcode = await cameraController.scan();\n\n    if (barcode == null) {\n      print('nothing return.');\n    } else {\n      this.outputController.text = barcode;\n      print(barcode);\n    }\n  }\n\n  _onCameraCreated(MyCameraController controller) {\n    this.cameraController = controller;\n\n    this.cameraController.getPictureSizes().then((pictureSizes) {\n      setState(() {\n        this.pictureSizes = pictureSizes!;\n      });\n    });\n  }\n\n  void _navigation() {\n    Navigator.push(\n      context,\n      new MaterialPageRoute(builder: (context) => new Home()),\n    );\n  }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/example/lib/main.dart b/example/lib/main.dart
--- a/example/lib/main.dart	
+++ b/example/lib/main.dart	
@@ -3,7 +3,6 @@
 import 'dart:typed_data';
 
 import 'package:custom_camera/my_cameranew.dart';
-import 'package:flutter/cupertino.dart';
 import 'package:flutter/material.dart';
 
 import 'new.dart';
@@ -156,14 +155,10 @@
   }
 
   Future _scan() async {
-    String barcode = await cameraController.scan();
-
-    if (barcode == null) {
-      print('nothing return.');
-    } else {
-      this.outputController.text = barcode;
-      print(barcode);
-    }
+    String? barcode;
+   barcode = await cameraController.scan();
+   this.outputController.text = barcode;
+    print(barcode);
   }
 
   _onCameraCreated(MyCameraController controller) {
Index: android/src/main/java/com/search/my_camera/MyCameraPlugin.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.search.my_camera;\n\nimport android.Manifest;\nimport com.google.android.gms.common.api.CommonStatusCodes;\nimport android.app.Activity;\nimport android.content.Intent;\nimport android.graphics.Bitmap;\nimport android.graphics.BitmapFactory;\nimport com.karumi.dexter.Dexter;\nimport com.karumi.dexter.MultiplePermissionsReport;\nimport com.karumi.dexter.PermissionToken;\nimport com.karumi.dexter.listener.PermissionRequest;\nimport com.karumi.dexter.listener.multi.MultiplePermissionsListener;\nimport android.content.Intent;\nimport java.util.List;\nimport android.net.Uri;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport android.os.Bundle;\nimport android.app.Activity;\nimport android.os.Handler;\nimport android.os.Looper;\nimport io.flutter.plugin.common.BinaryMessenger;\nimport androidx.annotation.NonNull;\nimport io.flutter.plugin.common.MethodCall;\nimport io.flutter.plugin.common.MethodChannel.MethodCallHandler;\nimport io.flutter.plugin.common.MethodChannel;\nimport io.flutter.plugin.common.MethodChannel.Result;\nimport io.flutter.plugin.common.PluginRegistry;\nimport io.flutter.plugin.common.PluginRegistry.Registrar;\n\nimport com.uuzuche.lib_zxing.activity.CodeUtils;\nimport com.uuzuche.lib_zxing.activity.ZXingLibrary;\n\nimport java.io.ByteArrayOutputStream;\nimport com.search.my_camera.OcrCaptureActivity;\nimport io.flutter.embedding.engine.plugins.activity.ActivityPluginBinding;\nimport static com.uuzuche.lib_zxing.activity.CodeUtils.RESULT_SUCCESS;\nimport static com.uuzuche.lib_zxing.activity.CodeUtils.RESULT_TYPE;\n\n\npublic class MyCameraPlugin implements MethodCallHandler,PluginRegistry.ActivityResultListener{\n    private Activity activity;\n    private static final String CHANNEL = \"my_camera\";\n    private static final int RC_OCR_READ = 8020;\n    private MethodCall methodCall;\n    private int callerId;\n\n    private int REQUEST_CODE = 100;\n    public Result result = null;\n    public Result result1 = null;\n    private MethodChannel channel;\n    public  MycameraDelegate delegate;\n    private MethodChannel.Result pendingResult;\n    private ActivityPluginBinding activityBinding;\n    private int REQUEST_IMAGE = 101;\n   /* private MyCameraPlugin(\n            Registrar registrar) {\n        this.activity = registrar.activity();\n    }*/\n\n    public static void registerWith(Registrar registrar) {\n      ZXingLibrary.initDisplayOpinion(registrar.activity());\n       // MyCameraPlugin plugin = new MyCameraPlugin(registrar.activity());\n//registrar.addActivityResultListener();\n        MyCameraPlugin plugin = new MyCameraPlugin(registrar.activity());\n        //methodChannel.setMethodCallHandler(plugin);\n        registrar.addActivityResultListener(plugin);\n      //  activityBinding.addRequestPermissionsResultListener(plugin);\n        //registrar.addRequestPermissionsResultListener(delegate);\n        registrar\n                .platformViewRegistry()\n                .registerViewFactory(\n                        \"plugins.flutter.io/my_camera\", new MyCameraFactory(registrar));\n\n       // final MethodChannel channel = new MethodChannel(registrar.messenger(), \"my_camera\");\n        MethodChannel channel = new MethodChannel(registrar.messenger(), \"my_camera\");\n       // channel.setMethodCallHandler(new MyCameraPlugin(plugin));\n        channel.setMethodCallHandler(plugin);\n        //channel.setMethodCallHandler(plugin);\n\n\n\n\n    }\n    private void setup(\n            final BinaryMessenger messenger,\n\n//            final Activity activity,\n            final PluginRegistry.Registrar registrar,\n            final ActivityPluginBinding activityBinding) {\n      //  this.activity = activity;\n      //  this.delegate = new MycameraDelegate(activity);\n        channel = new MethodChannel(messenger, CHANNEL);\n        channel.setMethodCallHandler(this);\n        if (registrar != null) {\n            // V1 embedding setup for activity listeners.\n            // registrar.addActivityResultListener(delegate);\n            //registrar.addRequestPermissionsResultListener(delegate);\n        } else {\n            // V2 embedding setup for activity listeners.\n            activityBinding.addActivityResultListener(delegate);\n            activityBinding.addRequestPermissionsResultListener(delegate);\n        }\n    }\n\n\n    public MyCameraPlugin(Activity activity) {\n    //   final BinaryMessenger messenger;\n        this.activity = activity;\n\n     this.delegate = new MycameraDelegate(activity);\n        CheckPermissionUtils.initPermission(this.activity);\n    }\n\n    private static class MethodResultWrapper implements MethodChannel.Result {\n        private MethodChannel.Result methodResult;\n        private Handler handler;\n\n        MethodResultWrapper(MethodChannel.Result result) {\n            methodResult = result;\n            handler = new Handler(Looper.getMainLooper());\n        }\n\n        @Override\n        public void success(final Object result) {\n            handler.post(\n                    new Runnable() {\n                        @Override\n                        public void run() {\n                            methodResult.success(result);\n                        }\n                    });\n        }\n\n        @Override\n        public void error(\n                final String errorCode, final String errorMessage, final Object errorDetails) {\n            handler.post(\n                    new Runnable() {\n                        @Override\n                        public void run() {\n                            methodResult.error(errorCode, errorMessage, errorDetails);\n                        }\n                    });\n        }\n\n        @Override\n        public void notImplemented() {\n            handler.post(\n                    new Runnable() {\n                        @Override\n                        public void run() {\n                            methodResult.notImplemented();\n                        }\n                    });\n        }\n    }\n    @Override\n    public void onMethodCall(MethodCall call, final Result result) {\n        if (call.method.equals(\"checkForPermission\")) {\n            checkForPermission(result);\n        } else {\n            result.notImplemented();\n        }\n        //this.result=result;\n\n       // MycameraDelegate.result=result;\n       // MethodChannel.Result resultnew = new MethodResultWrapper(result);\n       MethodChannel.Result result1 = new MethodResultWrapper(result);\n\n\n// MethodResultWrapper.Result result1 =result;\n\n       switch (call.method) {\n            case \"scan\":\n                delegate.scan(call, result);\n                break;\n\n            case \"read\":\n                delegate.read(call, result);\n                break;\n\n            case \"face\":\n                delegate.face(call, result);\n                break;\n        }\n\n    }\n    private void finishWithError(String errorCode, String errorMessage) {\n        if (pendingResult == null) {\n            // TODO - Return an error.\n            return;\n        }\n\n        pendingResult.error(errorCode, errorMessage, null);\n        clearMethodCallAndResult();\n    }\n\n    public boolean onActivityResult(int code, int resultCode, Intent intent) {\n\n        //System.out.println(\"hello : \"+intent.getExtras());\n      //  System.out.println(\"hello : \"+resul);\n      //  System.out.println(\"hello : \"+barcode);\n        if (code == REQUEST_CODE) {\n            if (resultCode == Activity.RESULT_OK && intent != null) {\n                Bundle secondBundle = intent.getBundleExtra(\"secondBundle\");\n                if (secondBundle != null) {\n                    try {\n                        CodeUtils.AnalyzeCallback analyzeCallback = new CustomAnalyzeCallback(this.result, intent);\n                        CodeUtils.analyzeBitmap(secondBundle.getString(\"path\"), analyzeCallback);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                } else {\n                    Bundle bundle = intent.getExtras();\n                    if (bundle != null) {\n                        if (bundle.getInt(RESULT_TYPE) == RESULT_SUCCESS) {\n                            String barcode = bundle.getString(CodeUtils.RESULT_STRING);\n                            System.out.println(\"barcode: \"+barcode);\n\n                            MyCamera.result.success(barcode);\n                        }else{\n                            this.result.success(null);\n                        }\n                    }\n                }\n            } else {\n                String errorCode = intent != null ? intent.getStringExtra(\"ERROR_CODE\") : null;\n                if (errorCode != null) {\n                    this.result.error(errorCode, null, null);\n                }\n            }\n            return true;\n        } else if (code == REQUEST_IMAGE) {\n            if (intent != null) {\n                Uri uri = intent.getData();\n                try {\n                    CodeUtils.AnalyzeCallback analyzeCallback = new CustomAnalyzeCallback(this.result, intent);\n                    CodeUtils.analyzeBitmap(ImageUtil.getImageAbsolutePath(activity, uri), analyzeCallback);\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n            }\n            return true;\n        }else if (code == RC_OCR_READ) {\n            if (code == CommonStatusCodes.SUCCESS) {\n                if (intent != null) {\n                    ArrayList<MyTextBlock> blocks = intent\n                            .getParcelableArrayListExtra(OcrCaptureActivity.OBJECT);\n                    if (blocks != null && !blocks.isEmpty()) {\n                        List<Map<String, Object>> list = new ArrayList<>();\n                        for (MyTextBlock block : blocks) {\n                            list.add(block.getMap());\n                        }\n                        System.out.println(\"hello : \"+list);\n\n                        finishWithSuccess(list);\n                        return true;\n                    }\n                }\n                finishWithError(\"No text recognized, intent data is null\", null);\n            } else if (resultCode == CommonStatusCodes.ERROR) {\n                if (intent != null) {\n                    Exception e = intent.getParcelableExtra(OcrCaptureActivity.ERROR);\n                    finishWithError(e.getMessage(), null);\n                } else {\n                    finishWithError(\"Intent is null (the camera permission may not be granted)\", null);\n                }\n            }\n        }\n        return false;\n\n    }\n\n\n\n    private void checkForPermission(final MethodChannel.Result result) {\n        Dexter.withActivity(activity)\n                .withPermissions(Manifest.permission.CAMERA, Manifest.permission.WRITE_EXTERNAL_STORAGE, Manifest.permission.READ_EXTERNAL_STORAGE)\n                .withListener(new MultiplePermissionsListener() {\n                    @Override\n                    public void onPermissionsChecked(MultiplePermissionsReport report) {\n                        result.success(report.areAllPermissionsGranted());\n                    }\n\n                    @Override\n                    public void onPermissionRationaleShouldBeShown(List<PermissionRequest> permissions, PermissionToken token) {\n                        token.continuePermissionRequest();\n                    }\n                })\n                .check();\n    }\n    private void finishWithSuccess(Object object) {\n        if (pendingResult == null) {\n            // TODO - Return an error.\n            return;\n        }\n\n        pendingResult.success(object);\n        clearMethodCallAndResult();\n    }\n    private void clearMethodCallAndResult() {\n        callerId = 0;\n        methodCall = null;\n        pendingResult = null;\n    }\n\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/android/src/main/java/com/search/my_camera/MyCameraPlugin.java b/android/src/main/java/com/search/my_camera/MyCameraPlugin.java
--- a/android/src/main/java/com/search/my_camera/MyCameraPlugin.java	
+++ b/android/src/main/java/com/search/my_camera/MyCameraPlugin.java	
@@ -1,45 +1,39 @@
 package com.search.my_camera;
 
+import static com.uuzuche.lib_zxing.activity.CodeUtils.RESULT_SUCCESS;
+import static com.uuzuche.lib_zxing.activity.CodeUtils.RESULT_TYPE;
+
 import android.Manifest;
-import com.google.android.gms.common.api.CommonStatusCodes;
 import android.app.Activity;
 import android.content.Intent;
-import android.graphics.Bitmap;
-import android.graphics.BitmapFactory;
+import android.net.Uri;
+import android.os.Bundle;
+import android.os.Handler;
+import android.os.Looper;
+
+import com.google.android.gms.common.api.CommonStatusCodes;
 import com.karumi.dexter.Dexter;
 import com.karumi.dexter.MultiplePermissionsReport;
 import com.karumi.dexter.PermissionToken;
 import com.karumi.dexter.listener.PermissionRequest;
 import com.karumi.dexter.listener.multi.MultiplePermissionsListener;
-import android.content.Intent;
-import java.util.List;
-import android.net.Uri;
+import com.search.my_camera.OcrCaptureActivity;
+import com.uuzuche.lib_zxing.activity.CodeUtils;
+import com.uuzuche.lib_zxing.activity.ZXingLibrary;
+
 import java.util.ArrayList;
-import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
-import android.os.Bundle;
-import android.app.Activity;
-import android.os.Handler;
-import android.os.Looper;
+
+import io.flutter.embedding.engine.plugins.activity.ActivityPluginBinding;
 import io.flutter.plugin.common.BinaryMessenger;
-import androidx.annotation.NonNull;
 import io.flutter.plugin.common.MethodCall;
+import io.flutter.plugin.common.MethodChannel;
 import io.flutter.plugin.common.MethodChannel.MethodCallHandler;
-import io.flutter.plugin.common.MethodChannel;
 import io.flutter.plugin.common.MethodChannel.Result;
 import io.flutter.plugin.common.PluginRegistry;
 import io.flutter.plugin.common.PluginRegistry.Registrar;
 
-import com.uuzuche.lib_zxing.activity.CodeUtils;
-import com.uuzuche.lib_zxing.activity.ZXingLibrary;
-
-import java.io.ByteArrayOutputStream;
-import com.search.my_camera.OcrCaptureActivity;
-import io.flutter.embedding.engine.plugins.activity.ActivityPluginBinding;
-import static com.uuzuche.lib_zxing.activity.CodeUtils.RESULT_SUCCESS;
-import static com.uuzuche.lib_zxing.activity.CodeUtils.RESULT_TYPE;
-
 
 public class MyCameraPlugin implements MethodCallHandler,PluginRegistry.ActivityResultListener{
     private Activity activity;
Index: lib/controller.dart
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>part of my_camera;\n\n/// Controller for a single GoogleMap instance running on the host platform.\nclass MyCameraController {\n  MyCameraController._(\n      this.channel,\n      this._myCameraState,\n      ) : assert(channel != null) {\n    channel.setMethodCallHandler(_handleMethodCall);\n  }\n\n  static Future<MyCameraController> init(\n      int id,\n      _MyCameraState myCameraState,\n      ) async {\n    assert(id != null);\n    final MethodChannel channel = MethodChannel('plugins.flutter.io/my_camera/$id');\n    // TODO(amirh): remove this on when the invokeMethod update makes it to stable Flutter.\n    await channel.invokeMethod('waitForCamera');\n    return MyCameraController._(\n      channel,\n      myCameraState,\n    );\n  }\n\n  @visibleForTesting\n  final MethodChannel channel;\n  //final CameraAccessDenied = 'PERMISSION_NOT_GRANTED';\n  final cameraaccessdenied = 'PERMISSION_NOT_GRANTED';\n  final _MyCameraState _myCameraState;\n\n  Future<dynamic> _handleMethodCall(MethodCall call) async {\n    switch (call.method) {\n      case \"onImageCaptured\":\n        String path = call.arguments['path'] as String;\n        _myCameraState.onImageCaptured(path);\n        break;\n      case \"onFlashTypeChanged\":\n        String types = call.arguments['types'] as String;\n        _myCameraState.onImageCaptured(types);\n        break;\n      default:\n        throw MissingPluginException();\n    }\n  }\n\n  Future<void> setSessionPreset( cameraSessionPreset) async {\n    // TODO(amirh): remove this on when the invokeMethod update makes it to stable Flutter.\n    if (Platform.isAndroid) return;\n\n    String? sessionPreset;\n\n\n    await channel.invokeMethod('setSessionPreset', <String, dynamic>{\n      'sessionPreset': sessionPreset,\n    });\n\n\n  //  _myCameraState.setState(() {});\n  }\n\n  Future<void> setPreviewRatio(CameraPreviewRatio cameraPreviewRatio) async {\n    // TODO(amirh): remove this on when the invokeMethod update makes it to stable Flutter.\n    if (Platform.isIOS) return;\n\n    String previewRatio;\n\n    switch (cameraPreviewRatio) {\n      case CameraPreviewRatio.r16_9:\n        previewRatio = \"16:9\";\n        break;\n      case CameraPreviewRatio.r11_9:\n        previewRatio = \"11:9\";\n        break;\n      case CameraPreviewRatio.r4_3:\n        previewRatio = \"4:3\";\n        break;\n      case CameraPreviewRatio.r1:\n        previewRatio = \"1:1\";\n        break;\n    }\n\n    bool success = await channel.invokeMethod('setPreviewRatio', <String, dynamic>{\n      'previewRatio': previewRatio,\n    });\n\n    if (success) {\n      _myCameraState._cameraPreviewRatio = cameraPreviewRatio;\n    }\n  }\n\n  Future<void> captureImage({int? maxSize}) async {\n    // TODO(amirh): remove this on when the invokeMethod update makes it to stable Flutter.\n    await channel.invokeMethod('captureImage', <String, dynamic>{\n      'maxSize': maxSize,\n    });\n  }\n\n  Future<void> switchCamera() async {\n    // TODO(amirh): remove this on when the invokeMethod update makes it to stable Flutter.\n\n    await channel.invokeMethod('switchCamera', null);\n  }\n\n  Future<void> turnOffCamera() async {\n    // TODO(amirh): remove this on when the invokeMethod update makes it to stable Flutter.\n    await channel.invokeMethod('turnOff', null);\n  }\n\n  Future<List<String>?> getPictureSizes() async {\n    // TODO(amirh): remove this on when the invokeMethod update makes it to stable Flutter.\n\n    var result = await channel.invokeMethod('getPictureSizes', null);\n\n    if (result == null) return null;\n\n    return List<String>.from(result);\n  }\n\n  Future<void> setPictureSize(int width, int height) async {\n    // TODO(amirh): remove this on when the invokeMethod update makes it to stable Flutter.\n\n    var x = await channel\n        .invokeMethod('setPictureSize', {\"pictureWidth\": width, \"pictureHeight\": height});\n\n    print(\"setPictureSize => $x\");\n  }\n\n  Future<void> setSavePath(String savePath) async {\n    // TODO(amirh): remove this on when the invokeMethod update makes it to stable Flutter.\n    if (Platform.isIOS) return;\n\n    var x = await channel.invokeMethod('setSavePath', {\"savePath\": savePath});\n\n    print(\"setSavePath => $x\");\n  }\n\n  Future<void> setFlashType(FlashType flashType) async {\n    // TODO(amirh): remove this on when the invokeMethod update makes it to stable Flutter.\n    String flashTypeString;\n\n    switch (flashType) {\n      case FlashType.auto:\n        flashTypeString = \"auto\";\n        break;\n      case FlashType.on:\n        flashTypeString = \"on\";\n        break;\n      case FlashType.off:\n        flashTypeString = \"off\";\n        break;\n      case FlashType.torch:\n        flashTypeString = \"torch\";\n        break;\n    }\n    var x = await channel.invokeMethod('setFlashType', {\"flashType\": flashTypeString});\n\n    print(\"setFlashType => $x\");\n  }\n\n  Future<List<FlashType>> getFlashType() async {\n    final types = await channel.invokeMethod('getFlashType');\n    print(\"getFlashType => $types\");\n    List<FlashType> finalTypes = [];\n\n    if (types == null) return finalTypes;\n\n    if (types is List) {\n      for (var each in types) {\n        if (each == \"on\") {\n          finalTypes.add(FlashType.on);\n        } else if (each == \"off\") {\n          finalTypes.add(FlashType.off);\n        } else if (each == \"torch\") {\n          finalTypes.add(FlashType.torch);\n        } else if (each == \"auto\") {\n          finalTypes.add(FlashType.auto);\n        }\n      }\n    }\n\n    return finalTypes;\n  }\n  Future<String> scan() async => await channel.invokeMethod('scan');\n\n  /// Scanning Photo Bar Code or QR Code return content\n  Future<String> scanPhoto() async => await channel.invokeMethod('scan_photo');\n\n// Scanning the image of the specified path\n  Future<String> scanPath(String path) async {\n    assert(path != null && path.isNotEmpty);\n    return await channel.invokeMethod('scan_path', {\"path\": path});\n  }\n\n// Parse to code string with uint8list\n  Future<String> scanBytes(Uint8List uint8list) async {\n    assert(uint8list != null && uint8list.isNotEmpty);\n    return await channel.invokeMethod('scan_bytes', {\"bytes\": uint8list});\n  }\n\n  /// Generating Bar Code Uint8List\n  Future<Uint8List> generateBarCode(String code) async {\n    assert(code != null && code.isNotEmpty);\n    return await channel.invokeMethod('generate_barcode', {\"code\": code});\n  }\n\n//  Future<void> changeCamera() async {\n//    // TODO(amirh): remove this on when the invokeMethod update makes it to stable Flutter.\n//    // https://github.com/flutter/flutter/issues/26431\n//    // ignore: strong_mode_implicit_dynamic_method\n//    await channel.invokeMethod('setMaxImage', <String, dynamic>{\n//      'maxImage': maxImage,\n//    });\n//  }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/lib/controller.dart b/lib/controller.dart
--- a/lib/controller.dart	
+++ b/lib/controller.dart	
@@ -5,7 +5,7 @@
   MyCameraController._(
       this.channel,
       this._myCameraState,
-      ) : assert(channel != null) {
+      ) {
     channel.setMethodCallHandler(_handleMethodCall);
   }
 
@@ -13,7 +13,6 @@
       int id,
       _MyCameraState myCameraState,
       ) async {
-    assert(id != null);
     final MethodChannel channel = MethodChannel('plugins.flutter.io/my_camera/$id');
     // TODO(amirh): remove this on when the invokeMethod update makes it to stable Flutter.
     await channel.invokeMethod('waitForCamera');
@@ -188,19 +187,19 @@
 
 // Scanning the image of the specified path
   Future<String> scanPath(String path) async {
-    assert(path != null && path.isNotEmpty);
+    assert(path.isNotEmpty);
     return await channel.invokeMethod('scan_path', {"path": path});
   }
 
 // Parse to code string with uint8list
   Future<String> scanBytes(Uint8List uint8list) async {
-    assert(uint8list != null && uint8list.isNotEmpty);
+    assert(uint8list.isNotEmpty);
     return await channel.invokeMethod('scan_bytes', {"bytes": uint8list});
   }
 
   /// Generating Bar Code Uint8List
   Future<Uint8List> generateBarCode(String code) async {
-    assert(code != null && code.isNotEmpty);
+    assert(code.isNotEmpty);
     return await channel.invokeMethod('generate_barcode', {"code": code});
   }
 
Index: lib/lifecycle_handler.dart
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import 'package:flutter/foundation.dart';\nimport 'package:flutter/material.dart';\n\nclass LifecycleEventHandler extends WidgetsBindingObserver {\n  final AsyncCallback onResumed;\n  final AsyncCallback onInactive;\n  final AsyncCallback onPaused;\n  final AsyncCallback onDetached;\n\n  LifecycleEventHandler({\n    required this.onResumed,\n    required this.onInactive,\n    required this.onPaused,\n    required this.onDetached,\n  });\n\n  @override\n  Future<Null> didChangeAppLifecycleState(AppLifecycleState state) async {\n    switch (state) {\n      case AppLifecycleState.resumed:\n        if (onResumed != null)\n          await onResumed();\n        break;\n      case AppLifecycleState.inactive:\n        if (onInactive != null)\n        await onInactive();\n        break;\n      case AppLifecycleState.paused:\n        if (onPaused != null)\n        await onPaused();\n        break;\n      case AppLifecycleState.detached:\n        if (onDetached != null)\n        await onDetached();\n        break;\n    }\n  }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/lib/lifecycle_handler.dart b/lib/lifecycle_handler.dart
--- a/lib/lifecycle_handler.dart	
+++ b/lib/lifecycle_handler.dart	
@@ -18,20 +18,16 @@
   Future<Null> didChangeAppLifecycleState(AppLifecycleState state) async {
     switch (state) {
       case AppLifecycleState.resumed:
-        if (onResumed != null)
-          await onResumed();
+        await onResumed();
         break;
       case AppLifecycleState.inactive:
-        if (onInactive != null)
-        await onInactive();
+      await onInactive();
         break;
       case AppLifecycleState.paused:
-        if (onPaused != null)
-        await onPaused();
+      await onPaused();
         break;
       case AppLifecycleState.detached:
-        if (onDetached != null)
-        await onDetached();
+      await onDetached();
         break;
     }
   }
Index: lib/my_cameranew.dart
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>library my_camera;\n\nimport 'dart:async';\nimport 'dart:io';\nimport 'package:flutter/foundation.dart';\nimport 'package:flutter/gestures.dart';\nimport 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\nimport 'my_camera_plugin.dart';\npart 'controller.dart';\n\nenum FlashType { auto, on, off, torch }\nenum CameraType { front, rear }\nenum CameraPreviewRatio { r16_9, r11_9, r4_3, r1 }\n\ntypedef void CameraCreatedCallback(MyCameraController controller);\ntypedef void ImageCapturedCallback(String path);\n\nclass MyCamera extends StatefulWidget {\n  final CameraType initialCameraType;\n  final CameraPreviewRatio cameraPreviewRatio;\n  static const int CAMERA_BACK = 0;\n  static const int CAMERA_FRONT = 1;\n\n  static const Size PREVIEW = Size(640, 480);\n\n  final CameraCreatedCallback onCameraCreated;\n  final ImageCapturedCallback onImageCaptured;\n  final FlashType flashType;\n  final bool bestPictureSize;\n  final String? fileNamePrefix;\n\n  const MyCamera({\n    Key? key,\n    CameraType? initialCameraType,\n    CameraPreviewRatio? cameraPreviewRatio,\n    FlashType? flashType,\n    bool? bestPictureSize,\n    required this.onCameraCreated,\n    required this.onImageCaptured,\n     this.fileNamePrefix,\n  })  : this.initialCameraType = initialCameraType ?? CameraType.rear,\n        this.cameraPreviewRatio =\n            cameraPreviewRatio ?? CameraPreviewRatio.r16_9,\n        this.flashType = flashType ?? FlashType.auto,\n        this.bestPictureSize = bestPictureSize ?? true,\n        super(key: key);\n\n  @override\n  _MyCameraState createState() => _MyCameraState();\n}\n\nclass _MyCameraState extends State<MyCamera> {\n  Set<Factory<OneSequenceGestureRecognizer>>? gestureRecognizers;\n  late CameraPreviewRatio _cameraPreviewRatio;\n\n  late FlashType _flashType;\n  bool hasPermission = false;\n\n\n  @override\n  void initState() {\n    super.initState();\n    _cameraPreviewRatio = widget.cameraPreviewRatio;\n\n    _flashType = widget.flashType;\n\n    MyCameraPlugin.checkForPermission().then((value) {\n      if (this.mounted)\n        setState(() {\n          hasPermission = value;\n        });\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    String previewRatio;\n    String? sessionPreset;\n    String flashType;\n\n    if (!hasPermission) return Center(child: CircularProgressIndicator());\n\n    switch (_flashType) {\n      case FlashType.on:\n        flashType = \"on\";\n        break;\n      case FlashType.off:\n        flashType = \"off\";\n        break;\n      case FlashType.auto:\n        flashType = \"auto\";\n        break;\n      case FlashType.torch:\n        flashType = \"torch\";\n        break;\n    }\n\n    switch (_cameraPreviewRatio) {\n      case CameraPreviewRatio.r16_9:\n        previewRatio = \"16:9\";\n        break;\n      case CameraPreviewRatio.r11_9:\n        previewRatio = \"11:9\";\n        break;\n      case CameraPreviewRatio.r4_3:\n        previewRatio = \"4:3\";\n        break;\n      case CameraPreviewRatio.r1:\n        previewRatio = \"1:1\";\n        break;\n    }\n\n    final Map<String, dynamic> creationParams = <String, dynamic>{\n      \"initialCameraType\":\n          widget.initialCameraType == CameraType.rear ? \"rear\" : \"front\",\n      \"previewRatio\": previewRatio,\n      \"sessionPreset\": sessionPreset,\n      \"flashType\": flashType,\n      \"fileNamePrefix\": widget.fileNamePrefix ?? \"my_camera\",\n      \"bestPictureSize\": widget.bestPictureSize,\n    };\n\n    Widget? camera;\n\n    if (defaultTargetPlatform == TargetPlatform.android) {\n      camera = AndroidView(\n        viewType: 'plugins.flutter.io/my_camera',\n        onPlatformViewCreated: onPlatformViewCreated,\n        gestureRecognizers: gestureRecognizers,\n        creationParams: creationParams,\n        creationParamsCodec: const StandardMessageCodec(),\n      );\n    } else if (defaultTargetPlatform == TargetPlatform.iOS) {\n      camera = UiKitView(\n        viewType: 'plugins.flutter.io/my_camera',\n        onPlatformViewCreated: onPlatformViewCreated,\n        gestureRecognizers: gestureRecognizers,\n        creationParams: creationParams,\n        creationParamsCodec: const StandardMessageCodec(),\n      );\n    }\n\n    return LayoutBuilder(\n      builder: (BuildContext context, BoxConstraints constraints) {\n        double lesser;\n        double greater;\n        double widthTemp;\n        double heightTemp;\n        double width;\n        double height;\n        double selectedPreviewRatio;\n        double constraintRatio;\n\n        if (constraints.maxWidth < constraints.maxHeight) {\n          greater = constraints.maxHeight;\n          lesser = constraints.maxWidth;\n          constraintRatio = constraints.maxWidth / constraints.maxHeight;\n        } else {\n          greater = constraints.maxWidth;\n          lesser = constraints.maxHeight;\n          constraintRatio = constraints.maxHeight / constraints.maxWidth;\n        }\n\n        switch (_cameraPreviewRatio) {\n          case CameraPreviewRatio.r16_9:\n            selectedPreviewRatio = 9.0 / 16.0;\n            if (constraintRatio >= selectedPreviewRatio) {\n              widthTemp = lesser;\n              heightTemp = lesser * 16.0 / 9.0;\n            } else {\n              heightTemp = greater;\n              widthTemp = greater * 9.0 / 16.0;\n            }\n            break;\n          case CameraPreviewRatio.r11_9:\n            selectedPreviewRatio = 9.0 / 11.0;\n            if (constraintRatio >= selectedPreviewRatio) {\n              widthTemp = lesser;\n              heightTemp = lesser * 11.0 / 9.0;\n            } else {\n              heightTemp = greater;\n              widthTemp = greater * 9.0 / 11.0;\n            }\n            break;\n          case CameraPreviewRatio.r4_3:\n            selectedPreviewRatio = 3.0 / 4.0;\n            if (constraintRatio >= selectedPreviewRatio) {\n              widthTemp = lesser;\n              heightTemp = lesser * 4.0 / 3.0;\n            } else {\n              heightTemp = greater;\n              widthTemp = greater * 3.0 / 4.0;\n            }\n            break;\n          case CameraPreviewRatio.r1:\n            if (constraintRatio >= 1.0) {\n              widthTemp = lesser;\n              heightTemp = lesser;\n            } else {\n              heightTemp = greater;\n              widthTemp = greater;\n            }\n            break;\n        }\n\n        if (Platform.isAndroid) {\n          if (constraints.maxWidth < constraints.maxHeight) {\n            width = widthTemp;\n            height = heightTemp;\n          } else {\n            width = heightTemp;\n            height = widthTemp;\n          }\n        } else {\n          width = constraints.maxWidth;\n          height = constraints.maxHeight;\n        }\n\n        return ClipRect(\n          child: OverflowBox(\n            maxWidth: width,\n            maxHeight: height,\n            child: camera,\n          ),\n          clipper: CustomRect(\n            right: constraints.maxWidth,\n            bottom: constraints.maxHeight,\n          ),\n        );\n      },\n    );\n  }\n\n  Future<void> onPlatformViewCreated(int id) async {\n    final MyCameraController controller = await MyCameraController.init(\n      id,\n      this,\n    );\n\n    if (widget.onCameraCreated != null) {\n      widget.onCameraCreated(controller);\n    }\n\n  }\n\n  /// @return the greatest common denominator\n  int findGcm(int a, int b) {\n    return b == 0 ? a : findGcm(b, a % b); // Not bad for one line of code :)\n  }\n\n  String asFraction(int a, int b) {\n    int gcm = findGcm(a, b);\n    return \"${(a / gcm)} : ${(b / gcm)}\";\n  }\n\n  void onImageCaptured(String path) {\n    if (widget.onImageCaptured != null) {\n      widget.onImageCaptured(path);\n    }\n  }\n}\n\nclass CustomRect extends CustomClipper<Rect> {\n  final double right;\n  final double bottom;\n\n  CustomRect({required this.right, required this.bottom});\n\n  @override\n  Rect getClip(Size size) {\n    Rect rect = Rect.fromLTRB(0.0, 0.0, right, bottom);\n    return rect;\n  }\n\n  @override\n  bool shouldReclip(CustomRect oldClipper) {\n    return true;\n  }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/lib/my_cameranew.dart b/lib/my_cameranew.dart
--- a/lib/my_cameranew.dart	
+++ b/lib/my_cameranew.dart	
@@ -238,9 +238,7 @@
       this,
     );
 
-    if (widget.onCameraCreated != null) {
-      widget.onCameraCreated(controller);
-    }
+    widget.onCameraCreated(controller);
 
   }
 
@@ -255,9 +253,7 @@
   }
 
   void onImageCaptured(String path) {
-    if (widget.onImageCaptured != null) {
-      widget.onImageCaptured(path);
-    }
+    widget.onImageCaptured(path);
   }
 }
 
Index: android/build.gradle
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>group 'com.search.my_camera'\nversion '1.0'\n\nbuildscript {\n    repositories {\n        google()\n        jcenter()\n    }\n\n    dependencies {\n        classpath 'com.android.tools.build:gradle:4.1.2'\n    }\n}\n\nrootProject.allprojects {\n    repositories {\n        google()\n        jcenter()\n        maven { url 'https://jitpack.io' }\n    }\n}\n\napply plugin: 'com.android.library'\n\nandroid {\n    compileSdkVersion 31\n\n    defaultConfig {\n        minSdkVersion 21\n        targetSdkVersion = 31\n\n        testInstrumentationRunner \"android.support.test.runner.AndroidJUnitRunner\"\n    }\n    lintOptions {\n        disable 'InvalidPackage'\n    }\n    dependencies {\n        implementation 'androidx.annotation:annotation:1.0.0'\n        implementation 'androidx.core:core:1.0.0'\n        implementation 'com.github.leyan95:android-zxingLibrary:0.1.2-PRE'\n        implementation 'androidx.appcompat:appcompat:1.0.0'\n        implementation 'com.github.bumptech.glide:glide:3.7.0'\n        implementation 'com.karumi:dexter:6.0.0'\n        api 'com.google.android.gms:play-services-vision:20.0.0'\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/android/build.gradle b/android/build.gradle
--- a/android/build.gradle	
+++ b/android/build.gradle	
@@ -27,7 +27,6 @@
 
     defaultConfig {
         minSdkVersion 21
-        targetSdkVersion = 31
 
         testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
     }
Index: lib/my_camera_plugin.dart
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import 'package:flutter/services.dart';\n\nclass MyCameraPlugin {\n  static const int CAMERA_BACK = 0;\n  static const int CAMERA_FRONT = 1;\n  static const MethodChannel _channel = const MethodChannel('my_camera',);\n\n\n\n  static Future<bool> checkForPermission() async {\n    return await _channel.invokeMethod('checkForPermission');\n\n  }\n  static final Map<int, List<Call>> _previewSizes = {};\n  static const Call PREVIEW = Call(640, 480);\n // static const MethodChannel channel = const MethodChannel('my_camera',);\n\n  ///\n  ///\n  ///\n  static List<Call>? getPreviewSizes(int facing) {\n    if (_previewSizes.containsKey(facing)) {\n      return _previewSizes[facing];\n    }\n    return null;\n  }\n\n  static Future<List<OcrText>> read({\n    bool flash = false,\n    bool autoFocus = true,\n    bool multiple = false,\n    bool waitTap = false,\n    bool showText = true,\n    Call preview = PREVIEW,\n    int camera = CAMERA_BACK,\n    double fps = 2.0,\n  }) async {\n    Map<String, dynamic> arguments = {\n      'flash': flash,\n      'autoFocus': autoFocus,\n      'multiple': multiple,\n      'waitTap': waitTap,\n      'showText': showText,\n      'previewWidth': preview != null ? preview.width : PREVIEW.width,\n      'previewHeight': preview != null ? preview.height : PREVIEW.height,\n      'camera': camera,\n      'fps': fps,\n    };\n\n    final List list = await _channel.invokeMethod('read', arguments);\n\n    return list.map((map) => OcrText.fromMap(map)).toList();\n  }\n\n}\nclass OcrText {\n  final String value;\n  final String language;\n  final int top;\n  final int bottom;\n  final int left;\n  final int right;\n\n  OcrText(\n      this.value, {\n        this.language = '',\n        this.top = -1,\n        this.bottom = -1,\n        this.left = -1,\n        this.right = -1,\n      });\n\n  OcrText.fromMap(Map map)\n      : value = map['value'],\n        language = map['language'],\n        top = map['top'],\n        bottom = map['bottom'],\n        left = map['left'],\n        right = map['right'];\n\n  Map<String, dynamic> toMap() {\n    return {\n      'value': value,\n      'language': language,\n      'top': top,\n      'bottom': bottom,\n      'left': left,\n      'right': right,\n    };\n  }\n}\nclass Call {\n  final int width;\n  final int height;\n\n  const Call(this.width, this.height);\n\n  Call.fromMap(Map map)\n      : width = map['width'],\n        height = map['height'];\n\n  @override\n  String toString() {\n    return '$width x $height';\n  }\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/lib/my_camera_plugin.dart b/lib/my_camera_plugin.dart
--- a/lib/my_camera_plugin.dart	
+++ b/lib/my_camera_plugin.dart	
@@ -41,12 +41,13 @@
       'multiple': multiple,
       'waitTap': waitTap,
       'showText': showText,
-      'previewWidth': preview != null ? preview.width : PREVIEW.width,
-      'previewHeight': preview != null ? preview.height : PREVIEW.height,
+      'previewWidth': preview.width ,
+      'previewHeight': preview.height,
       'camera': camera,
       'fps': fps,
     };
-
+    // 'previewWidth': preview != null ? preview.width : PREVIEW.width,
+    // 'previewHeight': preview != null ? preview.height : PREVIEW.height,
     final List list = await _channel.invokeMethod('read', arguments);
 
     return list.map((map) => OcrText.fromMap(map)).toList();
Index: .dart_tool/package_config.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>{\n  \"configVersion\": 2,\n  \"packages\": [\n    {\n      \"name\": \"async\",\n      \"rootUri\": \"file:///home/addweb/.pub-cache/hosted/pub.dev/async-2.10.0\",\n      \"packageUri\": \"lib/\",\n      \"languageVersion\": \"2.18\"\n    },\n    {\n      \"name\": \"boolean_selector\",\n      \"rootUri\": \"file:///home/addweb/.pub-cache/hosted/pub.dev/boolean_selector-2.1.1\",\n      \"packageUri\": \"lib/\",\n      \"languageVersion\": \"2.17\"\n    },\n    {\n      \"name\": \"characters\",\n      \"rootUri\": \"file:///home/addweb/.pub-cache/hosted/pub.dev/characters-1.2.1\",\n      \"packageUri\": \"lib/\",\n      \"languageVersion\": \"2.12\"\n    },\n    {\n      \"name\": \"clock\",\n      \"rootUri\": \"file:///home/addweb/.pub-cache/hosted/pub.dev/clock-1.1.1\",\n      \"packageUri\": \"lib/\",\n      \"languageVersion\": \"2.12\"\n    },\n    {\n      \"name\": \"collection\",\n      \"rootUri\": \"file:///home/addweb/.pub-cache/hosted/pub.dev/collection-1.17.0\",\n      \"packageUri\": \"lib/\",\n      \"languageVersion\": \"2.12\"\n    },\n    {\n      \"name\": \"fake_async\",\n      \"rootUri\": \"file:///home/addweb/.pub-cache/hosted/pub.dev/fake_async-1.3.1\",\n      \"packageUri\": \"lib/\",\n      \"languageVersion\": \"2.12\"\n    },\n    {\n      \"name\": \"flutter\",\n      \"rootUri\": \"file:///home/addweb/snap/flutter/common/flutter/packages/flutter\",\n      \"packageUri\": \"lib/\",\n      \"languageVersion\": \"2.17\"\n    },\n    {\n      \"name\": \"flutter_test\",\n      \"rootUri\": \"file:///home/addweb/snap/flutter/common/flutter/packages/flutter_test\",\n      \"packageUri\": \"lib/\",\n      \"languageVersion\": \"2.17\"\n    },\n    {\n      \"name\": \"js\",\n      \"rootUri\": \"file:///home/addweb/.pub-cache/hosted/pub.dev/js-0.6.5\",\n      \"packageUri\": \"lib/\",\n      \"languageVersion\": \"2.16\"\n    },\n    {\n      \"name\": \"matcher\",\n      \"rootUri\": \"file:///home/addweb/.pub-cache/hosted/pub.dev/matcher-0.12.13\",\n      \"packageUri\": \"lib/\",\n      \"languageVersion\": \"2.18\"\n    },\n    {\n      \"name\": \"material_color_utilities\",\n      \"rootUri\": \"file:///home/addweb/.pub-cache/hosted/pub.dev/material_color_utilities-0.2.0\",\n      \"packageUri\": \"lib/\",\n      \"languageVersion\": \"2.13\"\n    },\n    {\n      \"name\": \"meta\",\n      \"rootUri\": \"file:///home/addweb/.pub-cache/hosted/pub.dev/meta-1.8.0\",\n      \"packageUri\": \"lib/\",\n      \"languageVersion\": \"2.12\"\n    },\n    {\n      \"name\": \"path\",\n      \"rootUri\": \"file:///home/addweb/.pub-cache/hosted/pub.dev/path-1.8.2\",\n      \"packageUri\": \"lib/\",\n      \"languageVersion\": \"2.12\"\n    },\n    {\n      \"name\": \"sky_engine\",\n      \"rootUri\": \"file:///home/addweb/snap/flutter/common/flutter/bin/cache/pkg/sky_engine\",\n      \"packageUri\": \"lib/\",\n      \"languageVersion\": \"2.12\"\n    },\n    {\n      \"name\": \"source_span\",\n      \"rootUri\": \"file:///home/addweb/.pub-cache/hosted/pub.dev/source_span-1.9.1\",\n      \"packageUri\": \"lib/\",\n      \"languageVersion\": \"2.14\"\n    },\n    {\n      \"name\": \"stack_trace\",\n      \"rootUri\": \"file:///home/addweb/.pub-cache/hosted/pub.dev/stack_trace-1.11.0\",\n      \"packageUri\": \"lib/\",\n      \"languageVersion\": \"2.18\"\n    },\n    {\n      \"name\": \"stream_channel\",\n      \"rootUri\": \"file:///home/addweb/.pub-cache/hosted/pub.dev/stream_channel-2.1.1\",\n      \"packageUri\": \"lib/\",\n      \"languageVersion\": \"2.14\"\n    },\n    {\n      \"name\": \"string_scanner\",\n      \"rootUri\": \"file:///home/addweb/.pub-cache/hosted/pub.dev/string_scanner-1.2.0\",\n      \"packageUri\": \"lib/\",\n      \"languageVersion\": \"2.18\"\n    },\n    {\n      \"name\": \"term_glyph\",\n      \"rootUri\": \"file:///home/addweb/.pub-cache/hosted/pub.dev/term_glyph-1.2.1\",\n      \"packageUri\": \"lib/\",\n      \"languageVersion\": \"2.12\"\n    },\n    {\n      \"name\": \"test_api\",\n      \"rootUri\": \"file:///home/addweb/.pub-cache/hosted/pub.dev/test_api-0.4.16\",\n      \"packageUri\": \"lib/\",\n      \"languageVersion\": \"2.18\"\n    },\n    {\n      \"name\": \"vector_math\",\n      \"rootUri\": \"file:///home/addweb/.pub-cache/hosted/pub.dev/vector_math-2.1.4\",\n      \"packageUri\": \"lib/\",\n      \"languageVersion\": \"2.14\"\n    },\n    {\n      \"name\": \"custom_camera\",\n      \"rootUri\": \"../\",\n      \"packageUri\": \"lib/\",\n      \"languageVersion\": \"2.19\"\n    }\n  ],\n  \"generated\": \"2023-04-14T06:24:24.798481Z\",\n  \"generator\": \"pub\",\n  \"generatorVersion\": \"2.19.6\"\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.dart_tool/package_config.json b/.dart_tool/package_config.json
--- a/.dart_tool/package_config.json	
+++ b/.dart_tool/package_config.json	
@@ -2,6 +2,24 @@
   "configVersion": 2,
   "packages": [
     {
+      "name": "_fe_analyzer_shared",
+      "rootUri": "file:///home/addweb/.pub-cache/hosted/pub.dev/_fe_analyzer_shared-59.0.0",
+      "packageUri": "lib/",
+      "languageVersion": "2.17"
+    },
+    {
+      "name": "analyzer",
+      "rootUri": "file:///home/addweb/.pub-cache/hosted/pub.dev/analyzer-5.11.1",
+      "packageUri": "lib/",
+      "languageVersion": "2.19"
+    },
+    {
+      "name": "args",
+      "rootUri": "file:///home/addweb/.pub-cache/hosted/pub.dev/args-2.4.0",
+      "packageUri": "lib/",
+      "languageVersion": "2.18"
+    },
+    {
       "name": "async",
       "rootUri": "file:///home/addweb/.pub-cache/hosted/pub.dev/async-2.10.0",
       "packageUri": "lib/",
@@ -32,10 +50,34 @@
       "languageVersion": "2.12"
     },
     {
+      "name": "convert",
+      "rootUri": "file:///home/addweb/.pub-cache/hosted/pub.dev/convert-3.1.1",
+      "packageUri": "lib/",
+      "languageVersion": "2.18"
+    },
+    {
+      "name": "coverage",
+      "rootUri": "file:///home/addweb/.pub-cache/hosted/pub.dev/coverage-1.6.3",
+      "packageUri": "lib/",
+      "languageVersion": "2.18"
+    },
+    {
+      "name": "crypto",
+      "rootUri": "file:///home/addweb/.pub-cache/hosted/pub.dev/crypto-3.0.2",
+      "packageUri": "lib/",
+      "languageVersion": "2.14"
+    },
+    {
       "name": "fake_async",
       "rootUri": "file:///home/addweb/.pub-cache/hosted/pub.dev/fake_async-1.3.1",
       "packageUri": "lib/",
       "languageVersion": "2.12"
+    },
+    {
+      "name": "file",
+      "rootUri": "file:///home/addweb/.pub-cache/hosted/pub.dev/file-6.1.4",
+      "packageUri": "lib/",
+      "languageVersion": "2.12"
     },
     {
       "name": "flutter",
@@ -50,12 +92,48 @@
       "languageVersion": "2.17"
     },
     {
+      "name": "frontend_server_client",
+      "rootUri": "file:///home/addweb/.pub-cache/hosted/pub.dev/frontend_server_client-3.2.0",
+      "packageUri": "lib/",
+      "languageVersion": "2.12"
+    },
+    {
+      "name": "glob",
+      "rootUri": "file:///home/addweb/.pub-cache/hosted/pub.dev/glob-2.1.1",
+      "packageUri": "lib/",
+      "languageVersion": "2.15"
+    },
+    {
+      "name": "http_multi_server",
+      "rootUri": "file:///home/addweb/.pub-cache/hosted/pub.dev/http_multi_server-3.2.1",
+      "packageUri": "lib/",
+      "languageVersion": "2.12"
+    },
+    {
+      "name": "http_parser",
+      "rootUri": "file:///home/addweb/.pub-cache/hosted/pub.dev/http_parser-4.0.2",
+      "packageUri": "lib/",
+      "languageVersion": "2.12"
+    },
+    {
+      "name": "io",
+      "rootUri": "file:///home/addweb/.pub-cache/hosted/pub.dev/io-1.0.4",
+      "packageUri": "lib/",
+      "languageVersion": "2.12"
+    },
+    {
       "name": "js",
       "rootUri": "file:///home/addweb/.pub-cache/hosted/pub.dev/js-0.6.5",
       "packageUri": "lib/",
       "languageVersion": "2.16"
     },
     {
+      "name": "logging",
+      "rootUri": "file:///home/addweb/.pub-cache/hosted/pub.dev/logging-1.1.1",
+      "packageUri": "lib/",
+      "languageVersion": "2.18"
+    },
+    {
       "name": "matcher",
       "rootUri": "file:///home/addweb/.pub-cache/hosted/pub.dev/matcher-0.12.13",
       "packageUri": "lib/",
@@ -74,18 +152,84 @@
       "languageVersion": "2.12"
     },
     {
+      "name": "mime",
+      "rootUri": "file:///home/addweb/.pub-cache/hosted/pub.dev/mime-1.0.4",
+      "packageUri": "lib/",
+      "languageVersion": "2.18"
+    },
+    {
+      "name": "node_preamble",
+      "rootUri": "file:///home/addweb/.pub-cache/hosted/pub.dev/node_preamble-2.0.2",
+      "packageUri": "lib/",
+      "languageVersion": "2.12"
+    },
+    {
+      "name": "package_config",
+      "rootUri": "file:///home/addweb/.pub-cache/hosted/pub.dev/package_config-2.1.0",
+      "packageUri": "lib/",
+      "languageVersion": "2.12"
+    },
+    {
       "name": "path",
       "rootUri": "file:///home/addweb/.pub-cache/hosted/pub.dev/path-1.8.2",
       "packageUri": "lib/",
       "languageVersion": "2.12"
     },
     {
+      "name": "pool",
+      "rootUri": "file:///home/addweb/.pub-cache/hosted/pub.dev/pool-1.5.1",
+      "packageUri": "lib/",
+      "languageVersion": "2.12"
+    },
+    {
+      "name": "pub_semver",
+      "rootUri": "file:///home/addweb/.pub-cache/hosted/pub.dev/pub_semver-2.1.3",
+      "packageUri": "lib/",
+      "languageVersion": "2.17"
+    },
+    {
+      "name": "shelf",
+      "rootUri": "file:///home/addweb/.pub-cache/hosted/pub.dev/shelf-1.4.0",
+      "packageUri": "lib/",
+      "languageVersion": "2.17"
+    },
+    {
+      "name": "shelf_packages_handler",
+      "rootUri": "file:///home/addweb/.pub-cache/hosted/pub.dev/shelf_packages_handler-3.0.1",
+      "packageUri": "lib/",
+      "languageVersion": "2.14"
+    },
+    {
+      "name": "shelf_static",
+      "rootUri": "file:///home/addweb/.pub-cache/hosted/pub.dev/shelf_static-1.1.1",
+      "packageUri": "lib/",
+      "languageVersion": "2.14"
+    },
+    {
+      "name": "shelf_web_socket",
+      "rootUri": "file:///home/addweb/.pub-cache/hosted/pub.dev/shelf_web_socket-1.0.3",
+      "packageUri": "lib/",
+      "languageVersion": "2.17"
+    },
+    {
       "name": "sky_engine",
       "rootUri": "file:///home/addweb/snap/flutter/common/flutter/bin/cache/pkg/sky_engine",
       "packageUri": "lib/",
       "languageVersion": "2.12"
     },
     {
+      "name": "source_map_stack_trace",
+      "rootUri": "file:///home/addweb/.pub-cache/hosted/pub.dev/source_map_stack_trace-2.1.1",
+      "packageUri": "lib/",
+      "languageVersion": "2.12"
+    },
+    {
+      "name": "source_maps",
+      "rootUri": "file:///home/addweb/.pub-cache/hosted/pub.dev/source_maps-0.10.12",
+      "packageUri": "lib/",
+      "languageVersion": "2.18"
+    },
+    {
       "name": "source_span",
       "rootUri": "file:///home/addweb/.pub-cache/hosted/pub.dev/source_span-1.9.1",
       "packageUri": "lib/",
@@ -116,25 +260,73 @@
       "languageVersion": "2.12"
     },
     {
+      "name": "test",
+      "rootUri": "file:///home/addweb/.pub-cache/hosted/pub.dev/test-1.22.0",
+      "packageUri": "lib/",
+      "languageVersion": "2.18"
+    },
+    {
       "name": "test_api",
       "rootUri": "file:///home/addweb/.pub-cache/hosted/pub.dev/test_api-0.4.16",
       "packageUri": "lib/",
       "languageVersion": "2.18"
     },
     {
+      "name": "test_core",
+      "rootUri": "file:///home/addweb/.pub-cache/hosted/pub.dev/test_core-0.4.20",
+      "packageUri": "lib/",
+      "languageVersion": "2.18"
+    },
+    {
+      "name": "typed_data",
+      "rootUri": "file:///home/addweb/.pub-cache/hosted/pub.dev/typed_data-1.3.1",
+      "packageUri": "lib/",
+      "languageVersion": "2.12"
+    },
+    {
       "name": "vector_math",
       "rootUri": "file:///home/addweb/.pub-cache/hosted/pub.dev/vector_math-2.1.4",
       "packageUri": "lib/",
       "languageVersion": "2.14"
     },
     {
+      "name": "vm_service",
+      "rootUri": "file:///home/addweb/.pub-cache/hosted/pub.dev/vm_service-9.4.0",
+      "packageUri": "lib/",
+      "languageVersion": "2.15"
+    },
+    {
+      "name": "watcher",
+      "rootUri": "file:///home/addweb/.pub-cache/hosted/pub.dev/watcher-1.0.2",
+      "packageUri": "lib/",
+      "languageVersion": "2.14"
+    },
+    {
+      "name": "web_socket_channel",
+      "rootUri": "file:///home/addweb/.pub-cache/hosted/pub.dev/web_socket_channel-2.4.0",
+      "packageUri": "lib/",
+      "languageVersion": "2.15"
+    },
+    {
+      "name": "webkit_inspection_protocol",
+      "rootUri": "file:///home/addweb/.pub-cache/hosted/pub.dev/webkit_inspection_protocol-1.2.0",
+      "packageUri": "lib/",
+      "languageVersion": "2.12"
+    },
+    {
+      "name": "yaml",
+      "rootUri": "file:///home/addweb/.pub-cache/hosted/pub.dev/yaml-3.1.1",
+      "packageUri": "lib/",
+      "languageVersion": "2.12"
+    },
+    {
       "name": "custom_camera",
       "rootUri": "../",
       "packageUri": "lib/",
       "languageVersion": "2.19"
     }
   ],
-  "generated": "2023-04-14T06:24:24.798481Z",
+  "generated": "2023-04-28T09:58:21.749159Z",
   "generator": "pub",
   "generatorVersion": "2.19.6"
 }
Index: CHANGELOG.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>## 0.0.1\nAdd custom camera Plugin in flutter\n\n## 0.0.2-nullsafety\ncustom camera Plugin in flutter\n\n## 0.0.3-nullsafety\ncustom camera Plugin in flutter\n\n## 0.0.4-nullsafety\ncustom camera Plugin in flutter\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/CHANGELOG.md b/CHANGELOG.md
--- a/CHANGELOG.md	
+++ b/CHANGELOG.md	
@@ -1,12 +1,12 @@
 ## 0.0.1
 Add custom camera Plugin in flutter
 
-## 0.0.2-nullsafety
+## 0.0.2
 custom camera Plugin in flutter
 
-## 0.0.3-nullsafety
+## 0.0.3
 custom camera Plugin in flutter
 
-## 0.0.4-nullsafety
+## 0.0.4
 custom camera Plugin in flutter
 
Index: android/src/main/java/com/search/my_camera/MyCamera.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.search.my_camera;\nimport android.Manifest;\nimport android.annotation.SuppressLint;\nimport android.app.Activity;\nimport android.os.Handler;\nimport android.os.Looper;\nimport androidx.core.app.ActivityCompat;\nimport io.flutter.embedding.engine.plugins.FlutterPlugin;\nimport io.flutter.embedding.engine.plugins.activity.ActivityAware;\nimport io.flutter.embedding.engine.plugins.activity.ActivityPluginBinding;\nimport android.content.Context;\nimport android.graphics.Bitmap;\nimport android.graphics.BitmapFactory;\nimport io.flutter.plugin.common.BinaryMessenger;\nimport android.graphics.Matrix;\nimport android.graphics.Rect;\nimport android.hardware.Camera;\nimport android.hardware.SensorManager;\nimport android.os.AsyncTask;\nimport android.os.Build;\nimport android.content.pm.PackageManager;\nimport android.os.Environment;\nimport android.util.DisplayMetrics;\nimport android.util.Log;\nimport android.view.MotionEvent;\nimport android.view.OrientationEventListener;\nimport android.view.Surface;\nimport android.view.SurfaceHolder;\nimport android.view.SurfaceView;\nimport android.view.View;\nimport android.content.Intent;\nimport androidx.annotation.NonNull;\nimport android.graphics.Bitmap;\nimport android.graphics.BitmapFactory;\nimport android.util.Log;\nimport android.net.Uri;\nimport android.os.Bundle;\n\nimport io.flutter.plugin.common.MethodChannel;\nimport io.flutter.plugin.common.MethodChannel.MethodCallHandler;\nimport io.flutter.plugin.common.MethodChannel.Result;\nimport io.flutter.plugin.common.MethodCall;\nimport io.flutter.plugin.common.PluginRegistry;\nimport io.flutter.plugin.common.PluginRegistry.Registrar;\n\nimport com.uuzuche.lib_zxing.activity.CodeUtils;\nimport com.uuzuche.lib_zxing.activity.ZXingLibrary;\n\nimport java.io.ByteArrayOutputStream;\n\nimport static com.uuzuche.lib_zxing.activity.CodeUtils.RESULT_SUCCESS;\nimport static com.uuzuche.lib_zxing.activity.CodeUtils.RESULT_TYPE;\n\nimport com.karumi.dexter.MultiplePermissionsReport;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.text.DateFormat;\nimport java.text.SimpleDateFormat;\nimport java.util.ArrayList;\nimport java.util.Calendar;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport com.search.my_camera.BarcodeCaptureActivity;\nimport com.google.android.gms.common.api.CommonStatusCodes;\nimport com.google.android.gms.common.images.Size;\nimport com.google.android.gms.vision.barcode.Barcode;\nimport io.flutter.plugin.common.MethodCall;\nimport io.flutter.plugin.common.MethodChannel;\nimport io.flutter.plugin.common.PluginRegistry;\nimport io.flutter.plugin.platform.PlatformView;\nimport com.search.my_camera.CameraSourcePreview;\nimport com.search.my_camera.GraphicOverlay;\nimport io.flutter.plugin.common.PluginRegistry.ActivityResultListener;\n\nimport com.search.my_camera.CameraSource;\n\npublic class MyCamera implements MethodChannel.MethodCallHandler, PlatformView, SurfaceHolder.Callback {\n\n    private  MethodChannel methodChannel;\n\n    private MycameraDelegate delegate;\n    private  Context context;\n    private  Activity activity;\n    private boolean disposed = false;\n    private View view;\n    private SurfaceView imgSurface;\n    private SurfaceHolder surfaceHolder;\n    private Camera camera;\n    private int cameraFacing = 0;\n    private SavePicTask savePicTask;\n    private Camera.PictureCallback jpegCallback;\n    private File folder;\n    private Integer maxSize;\n    private String savePath;\n    private int REQUEST_IMAGE = 101;\n    private String fileNamePrefix = \"my_camera\";\n    private int iOrientation = 0;\n    private int mPhotoAngle = 90;\n    private String previewRatio;\n    private float mDist;\n    private int REQUEST_CODE = 100;\n    private ActivityPluginBinding activityBinding;\n    private Camera.Size pictureSize;\n    private String flashType = Camera.Parameters.FLASH_MODE_AUTO;\n    private boolean bestPictureSize;\n    public static  Result result = null;\n    private static final String CHANNEL = \"my_camera\";\n\n    public static final int RC_BARCODE_SCAN = 9010;\n    public static final int RC_OCR_READ = 8020;\n    public static final int RC_FACE_DETECT = 7030;\n    public static final int RC_START = 6040;\n\n    public static final int REQUEST_CAMERA_PERMISSION = 2345;\n\n    public int callerId;\n    public MethodChannel.Result pendingResult;\n   public MethodCall methodCall;\n    public boolean useFlash = false;\n    public boolean autoFocus = true;\n    private int formats = Barcode.ALL_FORMATS;\n    public boolean multiple = false;\n    public boolean waitTap = false;\n    public boolean showText = false;\n    public int previewWidth = 640;\n    public int previewHeight = 480;\n    public int mycamera = CameraSource.CAMERA_FACING_BACK;\n    public float fps = 15.0f;\n\n   /* public  void registerWith(Registrar registrar) {\n        methodChannel = new MethodChannel(registrar.messenger(), \"my_camera\");\n        MyCamera plugin = new MyCamera(registrar.activity());\n        methodChannel.setMethodCallHandler(plugin);\n        registrar.addActivityResultListener(plugin);\n\n        //  ZXingLibrary.initDisplayOpinion(registrar.activity());\n    }*/\n\n\n  /* public MyCamera(Activity activity) {\n       this.activity = activity;\n   }*/\n\n    MyCamera(\n            int id,\n            final Context context,\n            PluginRegistry.Registrar registrar, Object args) {\n        this.context = context;\n      //  MyCamera plugin =  MyCamera(registrar.activity());\n        //registrar.addActivityResultListener();\n        this.activity = registrar.activity();\n\n        methodChannel =\n                new MethodChannel(registrar.messenger(), \"plugins.flutter.io/my_camera/\" + id);\n        methodChannel.setMethodCallHandler(this);\n        view = registrar.activity().getLayoutInflater().inflate(com.search.my_camera.R.layout.activity_camera, null);\n        //qr = registrar.activity().getLayoutInflater().inflate(com.search.my_camera.R.layout.activity_second, null);\n        imgSurface = view.findViewById(com.search.my_camera.R.id.imgSurface);\n        com.search.my_camera.CameraFragment cameraFragment = (com.search.my_camera.CameraFragment) activity.getFragmentManager().findFragmentById(com.search.my_camera.R.id.cameraFragment);\n        imgSurface.setFocusable(true);\n        imgSurface.setFocusableInTouchMode(true);\n\n        cameraFragment.listener = new com.search.my_camera.FragmentLifecycleListener() {\n            @Override\n            public void onPause() {\n                if (camera != null)\n                camera.stopPreview();\n            }\n\n            @Override\n            public void onResume() {\n\n                setupCamera();\n            }\n        };\n\n        if (args instanceof HashMap) {\n            @SuppressWarnings({\"unchecked\"})\n            Map<String, Object> params = (Map<String, Object>) args;\n            Object initialCamera = params.get(\"initialCameraType\");\n            Object flashType = params.get(\"flashType\");\n            Object savePath = params.get(\"savePath\");\n            Object previewRatio = params.get(\"previewRatio\");\n            Object fileNamePrefix = params.get(\"fileNamePrefix\");\n            Object maxSize = params.get(\"maxSize\");\n            Object bestPictureSize = params.get(\"bestPictureSize\");\n\n            if (initialCamera != null) {\n                if (initialCamera.equals(\"front\")) {\n                    cameraFacing = 1;\n                } else if (initialCamera.equals(\"rear\")) {\n                    cameraFacing = 0;\n                }\n            }\n\n            if (flashType != null) {\n                this.flashType = flashType.toString();\n            }\n\n            if (savePath != null) {\n                this.savePath = savePath.toString();\n            } else {\n                this.savePath = Environment.getExternalStorageDirectory() + \"/images\";\n            }\n\n            if (previewRatio != null) {\n                this.previewRatio = previewRatio.toString();\n            } else {\n                this.previewRatio = \"16:9\";\n            }\n\n            if (fileNamePrefix != null) {\n                this.fileNamePrefix = fileNamePrefix.toString();\n            }\n\n            if (maxSize != null) {\n                this.maxSize = (Integer) maxSize;\n            }\n\n            if (bestPictureSize != null) {\n                this.bestPictureSize = Boolean.valueOf(bestPictureSize.toString());\n            }\n        }\n\n        imgSurface.setOnTouchListener(new View.OnTouchListener() {\n            @Override\n            public boolean onTouch(View v, MotionEvent event) {\n                // Get the pointer ID\n                Camera.Parameters params = camera.getParameters();\n\n                int action = event.getAction();\n\n                if (event.getPointerCount() > 1) {\n                    // handle multi-touch events\n                    if (action == MotionEvent.ACTION_POINTER_DOWN) {\n                        mDist = getFingerSpacing(event);\n                    } else if (action == MotionEvent.ACTION_MOVE && params.isZoomSupported()) {\n                        camera.cancelAutoFocus();\n                        handleZoom(event, params);\n                    }\n                } else {\n                    // handle single touch events\n                    if (action == MotionEvent.ACTION_UP) {\n                        handleFocus(event);\n                    }\n                }\n                return true;\n            }\n        });\n\n\n        folder = new File(this.savePath);\n        if (!folder.exists()) {\n            folder.mkdirs();\n        }\n\n        surfaceHolder = imgSurface.getHolder();\n        surfaceHolder.addCallback(this);\n        surfaceHolder.setType(SurfaceHolder.SURFACE_TYPE_PUSH_BUFFERS);\n        jpegCallback = new Camera.PictureCallback() {\n            public void onPictureTaken(byte[] data, Camera camera) {\n                camera.stopPreview();\n\n                cancelSavePicTaskIfNeed();\n                savePicTask = new SavePicTask(data, getPhotoRotation());\n                savePicTask.executeOnExecutor(AsyncTask.SERIAL_EXECUTOR);\n            }\n        };\n\n        identifyOrientationEvents();\n    }\n\n    private void captureImage() {\n        camera.takePicture(null, null, jpegCallback);\n    }\n\n    private static class MethodResultWrapper implements MethodChannel.Result {\n        private MethodChannel.Result methodResult;\n        private Handler handler;\n\n        MethodResultWrapper(MethodChannel.Result result) {\n            methodResult = result;\n            handler = new Handler(Looper.getMainLooper());\n        }\n\n        @Override\n        public void success(final Object result) {\n            handler.post(\n                    new Runnable() {\n                        @Override\n                        public void run() {\n                            methodResult.success(result);\n                        }\n                    });\n        }\n\n        @Override\n        public void error(\n                final String errorCode, final String errorMessage, final Object errorDetails) {\n            handler.post(\n                    new Runnable() {\n                        @Override\n                        public void run() {\n                            methodResult.error(errorCode, errorMessage, errorDetails);\n                        }\n                    });\n        }\n\n        @Override\n        public void notImplemented() {\n            handler.post(\n                    new Runnable() {\n                        @Override\n                        public void run() {\n                            methodResult.notImplemented();\n                        }\n                    });\n        }\n    }\n    public MyCamera(Activity activity) {\n        //   final BinaryMessenger messenger;\n        this.activity = activity;\n\n        this.delegate = new MycameraDelegate(activity);\n        CheckPermissionUtils.initPermission(this.activity);\n    }\n\n    @Override\n    public void onMethodCall(MethodCall methodCall, @NonNull MethodChannel.Result result) {\n        MethodChannel.Result result1 = new MethodResultWrapper(result);\n        switch (methodCall.method) {\n            case \"waitForCamera\":\n                result.success(null);\n                break;\n            case \"turnOff\":\n                camera.stopPreview();\n                result.success(null);\n                break;\n            case \"scan\":\n                this.result = result;\n                showBarcodeView();\n                break;\n            case \"scan_photo\":\n                this.result = result;\n                choosePhotos();\n                break;\n            case \"scan_path\":\n                this.result = result;\n                String path = methodCall.argument(\"path\");\n                CodeUtils.AnalyzeCallback analyzeCallback = new CustomAnalyzeCallback(this.result, this.activity.getIntent());\n                CodeUtils.analyzeBitmap(path, analyzeCallback);\n                break;\n            case \"scan_bytes\":\n                this.result = result;\n                byte[] bytes = methodCall.argument(\"bytes\");\n                Bitmap  bitmap = BitmapFactory.decodeByteArray(bytes , 0, bytes != null ? bytes.length : 0);\n                CodeUtils.analyzeBitmap(bitmap, new CustomAnalyzeCallback(this.result, this.activity.getIntent()));\n                break;\n            case \"generate_barcode\":\n                this.result = result;\n                generateQrCode(methodCall);\n                break;\n            default:\n                result.notImplemented();\n                break;\n            case \"setPreviewRatio\": {\n                String previewRatio = \"\";\n\n                if (methodCall.arguments instanceof HashMap) {\n                    @SuppressWarnings({\"unchecked\"})\n                    Map<String, Object> params = (Map<String, Object>) methodCall.arguments;\n                    Object previewRatioRaw = params.get(\"previewRatio\");\n                    previewRatio = previewRatioRaw == null ? null : previewRatioRaw.toString();\n                }\n\n                Camera.Parameters param = camera.getParameters();\n\n                List<Camera.Size> sizes = param.getSupportedPreviewSizes();\n                Camera.Size selectedSize = null;\n                for (Camera.Size size : sizes) {\n                    if (asFraction(size.width, size.height).equals(previewRatio)) {\n                        selectedSize = size;\n                        break;\n                    }\n                }\n\n                if (selectedSize == null) {\n                    result.success(false);\n                    return;\n                }\n\n                this.previewRatio = previewRatio;\n\n                param.setPreviewSize(selectedSize.width, selectedSize.height);\n\n                camera.stopPreview();\n                camera.setParameters(param);\n                try {\n                    camera.setPreviewDisplay(surfaceHolder);\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                camera.startPreview();\n\n                result.success(true);\n                break;\n            }\n            case \"captureImage\":\n                Integer maxSize = null;\n\n                if (methodCall.arguments instanceof HashMap) {\n                    @SuppressWarnings({\"unchecked\"})\n                    Map<String, Object> params = (Map<String, Object>) methodCall.arguments;\n                    maxSize = params.get(\"maxSize\") == null ? null : (Integer) params.get(\"maxSize\");\n                }\n\n                if (maxSize != null) {\n                    this.maxSize = maxSize;\n                }\n\n                captureImage();\n\n                result.success(true);\n                break;\n            case \"switchCamera\":\n                if (cameraFacing == 0) {\n                    cameraFacing = 1;\n                } else {\n                    cameraFacing = 0;\n                }\n\n                camera.stopPreview();\n                camera.release();\n                setupCamera();\n                result.success(true);\n                break;\n            case \"getPictureSizes\": {\n                List<String> pictureSizes = new ArrayList<>();\n\n                Camera.Parameters param = camera.getParameters();\n\n                List<Camera.Size> sizes = param.getSupportedPictureSizes();\n                for (Camera.Size size : sizes) {\n                    pictureSizes.add(size.width + \":\" + size.height);\n                }\n\n                result.success(pictureSizes);\n                break;\n            }\n            case \"setPictureSize\": {\n                int pictureWidth = 0;\n                int pictureHeight = 0;\n                String error = \"\";\n\n                if (methodCall.arguments instanceof HashMap) {\n                    @SuppressWarnings({\"unchecked\"})\n                    Map<String, Object> params = (Map<String, Object>) methodCall.arguments;\n                    pictureWidth = (int) params.get(\"pictureWidth\");\n                    pictureHeight = (int) params.get(\"pictureHeight\");\n                }\n\n                Camera.Parameters param = camera.getParameters();\n\n                param.setPictureSize(pictureWidth, pictureHeight);\n\n                camera.stopPreview();\n\n                try {\n                    camera.setParameters(param);\n                    camera.setPreviewDisplay(surfaceHolder);\n                    this.pictureSize = camera.new Size(pictureWidth, pictureHeight);\n                } catch (IOException e) {\n                    error = e.getMessage();\n                } catch (RuntimeException e) {\n                    error = e.getMessage();\n                }\n\n                camera.startPreview();\n\n                if (error.isEmpty()) {\n                    result.success(true);\n                } else {\n                    result.error(\"Camera Error\", \"setPictureSize\", error);\n                }\n                break;\n            }\n            case \"setSavePath\":\n                if (methodCall.arguments instanceof HashMap) {\n                    @SuppressWarnings({\"unchecked\"})\n                    Map<String, Object> params = (Map<String, Object>) methodCall.arguments;\n                    this.savePath = params.get(\"savePath\") == null ? null : params.get(\"savePath\").toString();\n                }\n\n                folder = new File(this.savePath);\n\n                if (!folder.exists()) {\n                    folder.mkdirs();\n                }\n\n                result.success(true);\n                break;\n            case \"getFlashType\": {\n                Camera.Parameters param = camera.getParameters();\n                result.success(param.getSupportedFlashModes());\n                break;\n            }\n\n\n            case \"setFlashType\": {\n                String flashType = \"auto\";\n\n                if (methodCall.arguments instanceof HashMap) {\n                    @SuppressWarnings({\"unchecked\"})\n                    Map<String, Object> params = (Map<String, Object>) methodCall.arguments;\n                    flashType = params.get(\"flashType\") == null ? \"auto\" : params.get(\"flashType\").toString();\n                }\n\n                Camera.Parameters param = camera.getParameters();\n\n                if (this.flashType.equals(\"torch\") && flashType.equals(\"on\")) {\n                    param.setFlashMode(\"off\");\n                    camera.setParameters(param);\n                }\n\n                if (flashType.equals(\"torch\")) {\n                    List<String> supportedFlashModes = param.getSupportedFlashModes();\n\n                    if (supportedFlashModes != null) {\n                        if (supportedFlashModes.contains(Camera.Parameters.FLASH_MODE_TORCH)) {\n                            this.flashType = Camera.Parameters.FLASH_MODE_TORCH;\n                        } else if (supportedFlashModes.contains(Camera.Parameters.FLASH_MODE_ON)) {\n                            this.flashType = Camera.Parameters.FLASH_MODE_ON;\n                        }\n                    }\n                } else {\n                    this.flashType = flashType;\n                }\n\n                param.setFlashMode(translateFlashType(param.getSupportedFlashModes()));\n\n                camera.stopPreview();\n                camera.setParameters(param);\n                try {\n                    camera.setPreviewDisplay(surfaceHolder);\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                camera.startPreview();\n\n                result.success(true);\n                break;\n            }\n        }\n    }\n\n    @Override\n    public View getView() {\n        return view;\n    }\n    private void showBarcodeView() {\n        Intent intent = new Intent(activity, SecondActivity.class);\n        activity.startActivityForResult(intent, REQUEST_CODE);\n    }\n    private void choosePhotos() {\n        Intent intent = new Intent();\n        intent.setAction(Intent.ACTION_PICK);\n        intent.setType(\"image/*\");\n        activity.startActivityForResult(intent, REQUEST_IMAGE);\n    }\n    private void generateQrCode(MethodCall call) {\n        String code = call.argument(\"code\");\n        Bitmap bitmap = CodeUtils.createImage(code, 400, 400, null);\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        bitmap.compress(Bitmap.CompressFormat.JPEG, 100, baos);\n        byte[] datas = baos.toByteArray();\n        this.result.success(datas);\n\n    }\n\n    private void setup(\n            final BinaryMessenger messenger,\n\n            final Activity activity,\n            final PluginRegistry.Registrar registrar,\n            final ActivityPluginBinding activityBinding) {\n        this.activity = activity;\n        this.delegate = new MycameraDelegate(activity);\n        methodChannel = new MethodChannel(messenger, CHANNEL);\n        methodChannel.setMethodCallHandler(this);\n        if (registrar != null) {\n            // V1 embedding setup for activity listeners.\n            registrar.addActivityResultListener(delegate);\n            registrar.addRequestPermissionsResultListener(delegate);\n        } else {\n            // V2 embedding setup for activity listeners.\n            activityBinding.addActivityResultListener(delegate);\n            activityBinding.addRequestPermissionsResultListener(delegate);\n        }\n    }\n\n    private void tearDown() {\n        activityBinding.removeActivityResultListener(delegate);\n        activityBinding.removeRequestPermissionsResultListener(delegate);\n        activityBinding = null;\n        delegate = null;\n        methodChannel.setMethodCallHandler(null);\n        methodChannel = null;\n    }\n\n    @Override\n    public void dispose() {\n        if (disposed) {\n            return;\n        }\n        disposed = true;\n        methodChannel.setMethodCallHandler(null);\n\n        com.search.my_camera.CameraFragment f = (com.search.my_camera.CameraFragment) activity.getFragmentManager()\n                .findFragmentById(com.search.my_camera.R.id.cameraFragment);\n        if (f != null) {\n            activity.getFragmentManager().beginTransaction().remove(f).commit();\n        }\n    }\n\n    @Override\n    public void surfaceCreated(SurfaceHolder holder) {\n        setupCamera();\n    }\n\n    private void setupCamera() {\n        try {\n            if (cameraFacing == 0) {\n                camera = Camera.open(0);\n            } else {\n                camera = Camera.open(1);\n            }\n        } catch (RuntimeException e) {\n            e.printStackTrace();\n            return;\n        }\n\n        try {\n            Camera.Parameters param = camera.getParameters();\n\n            if (this.bestPictureSize) {\n                List<Camera.Size> sizes2 = param.getSupportedPictureSizes();\n                Collections.sort(sizes2, new Comparator<Camera.Size>() {\n                    @Override\n                    public int compare(Camera.Size o1, Camera.Size o2) {\n                        return (o2.width - o1.width) + (o2.height - o1.height);\n                    }\n                });\n\n                pictureSize = sizes2.get(0);\n            } else {\n                pictureSize = param.getPictureSize();\n            }\n\n            List<Camera.Size> sizes = param.getSupportedPreviewSizes();\n            Camera.Size selectedSize = sizes.get(0);\n            for (Camera.Size size : sizes) {\n                if (asFraction(size.width, size.height).equals(this.previewRatio)) {\n                    selectedSize = size;\n                    break;\n                }\n            }\n\n            //get diff to get perfact preview sizes\n            DisplayMetrics displaymetrics = new DisplayMetrics();\n            activity.getWindowManager().getDefaultDisplay().getMetrics(displaymetrics);\n\n            param.setPreviewSize(selectedSize.width, selectedSize.height);\n            param.setPictureSize(pictureSize.width, pictureSize.height);\n            param.setFlashMode(translateFlashType(param.getSupportedFlashModes()));\n\n            List<String> supportedFocusMode = param.getSupportedFocusModes();\n            String focusMode = Camera.Parameters.FOCUS_MODE_CONTINUOUS_PICTURE;\n            if (!supportedFocusMode.contains(Camera.Parameters.FOCUS_MODE_CONTINUOUS_PICTURE)) {\n                if (supportedFocusMode.size() > 0) {\n                    focusMode = supportedFocusMode.get(0);\n                }\n            }\n            param.setFocusMode(focusMode);\n\n            int orientation = setCameraDisplayOrientation(0);\n\n\n            try {\n                camera.setParameters(param);\n            } catch (RuntimeException e) {\n                Log.d(\"MyCamera\", \"set Parameters Failed\\n\" + pictureSize.width + \", \" + pictureSize.height);\n            }\n\n            camera.setPreviewDisplay(surfaceHolder);\n            camera.startPreview();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n\n    public String translateFlashType(List<String> supportedModes) {\n        String result = this.flashType;\n\n        if (cameraFacing == 1) {\n            if (!this.flashType.equals(\"off\")) {\n                result = \"on\";\n            }\n        }\n\n        Log.d(\"ri\", \"flashtype \" + supportedModes);\n\n        if (supportedModes != null && !supportedModes.contains(result)) {\n            if (supportedModes.size() > 0) {\n                result = supportedModes.get(0);\n            } else {\n                result = \"\";\n            }\n        }\n\n        return result;\n    }\n\n    @Override\n    public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) {\n        refreshCamera();\n    }\n\n    @Override\n    public void surfaceDestroyed(SurfaceHolder holder) {\n        try {\n            camera.stopPreview();\n            camera.release();\n            camera = null;\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private int setCameraDisplayOrientation(int cameraId) {\n        Camera.CameraInfo info = new Camera.CameraInfo();\n        Camera.getCameraInfo(cameraId, info);\n\n        int rotation = activity.getWindowManager().getDefaultDisplay().getRotation();\n\n        if (Build.MODEL.equalsIgnoreCase(\"Nexus 6\") && cameraFacing == 1) {\n            rotation = Surface.ROTATION_180;\n        }\n\n        int degrees = 0;\n        switch (rotation) {\n\n            case Surface.ROTATION_0:\n                degrees = 0;\n                break;\n            case Surface.ROTATION_90:\n                degrees = 90;\n                break;\n            case Surface.ROTATION_180:\n                degrees = 180;\n                break;\n            case Surface.ROTATION_270:\n                degrees = 270;\n                break;\n        }\n\n        int result;\n\n        if (info.facing == Camera.CameraInfo.CAMERA_FACING_FRONT) {\n\n            result = (info.orientation + degrees) % 360;\n            result = (360 - result) % 360; // compensate the mirror\n\n        } else {\n            result = (info.orientation - degrees + 360) % 360;\n\n        }\n\n        camera.setDisplayOrientation(result);\n\n        return result;\n\n    }\n\n    private void refreshCamera() {\n        if (surfaceHolder.getSurface() == null) {\n            return;\n        }\n        try {\n            camera.stopPreview();\n            Camera.Parameters param = camera.getParameters();\n            param.setFlashMode(translateFlashType(param.getSupportedFlashModes()));\n            refreshCameraPreview(param);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void refreshCameraPreview(Camera.Parameters param) {\n        try {\n            //this is unnecessary because on certain device (Xiaomi 4A / Huawei) it is rotated\n            int orientation = setCameraDisplayOrientation(0);\n//            param.setRotation(orientation);\n            camera.setParameters(param);\n\n            camera.setPreviewDisplay(surfaceHolder);\n            camera.startPreview();\n\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void cancelSavePicTaskIfNeed() {\n        if (savePicTask != null && savePicTask.getStatus() == AsyncTask.Status.RUNNING) {\n            savePicTask.cancel(true);\n        }\n    }\n\n    @SuppressLint(\"StaticFieldLeak\")\n    private class SavePicTask extends AsyncTask<Void, Void, String> {\n        private byte[] data;\n        private int rotation;\n\n        SavePicTask(byte[] data, int rotation) {\n            this.data = data;\n            this.rotation = rotation;\n        }\n\n        protected void onPreExecute() {\n\n        }\n\n        @Override\n        protected String doInBackground(Void... params) {\n            try {\n                return saveToSDCard(data, rotation);\n            } catch (Exception e) {\n                e.printStackTrace();\n                return null;\n            }\n        }\n\n        @Override\n        protected void onPostExecute(String result) {\n            Map<String, Object> params = new HashMap<>();\n            params.put(\"path\", result);\n            methodChannel.invokeMethod(\"onImageCaptured\", params);\n\n            refreshCamera();\n\n        }\n    }\n\n    private String saveToSDCard(byte[] data, int rotation) {\n        String imagePath = \"\";\n\n        try {\n            final BitmapFactory.Options options = new BitmapFactory.Options();\n            options.inJustDecodeBounds = true;\n            BitmapFactory.decodeByteArray(data, 0, data.length, options);\n\n            DisplayMetrics metrics = new DisplayMetrics();\n            activity.getWindowManager().getDefaultDisplay().getMetrics(metrics);\n\n            int reqHeight = metrics.heightPixels;\n            int reqWidth = metrics.widthPixels;\n            // Fix for exporting image with correct resolution in landscape mode\n            if(reqWidth > reqHeight){\n            reqHeight = metrics.widthPixels;\n            reqWidth = metrics.heightPixels;\n            }\n\n\n\n            options.inSampleSize = calculateInSampleSize(options, reqWidth, reqHeight);\n\n            options.inJustDecodeBounds = false;\n            Bitmap bitmap = BitmapFactory.decodeByteArray(data, 0, data.length, options);\n\n            if (Build.MODEL.equalsIgnoreCase(\"LGM-G600L\")) {\n                //for now there's a case for LGM-G600L phone that its rotation degree exceeded by 90\n                rotation -= 90;\n            }\n\n            if (maxSize != null) {\n                double initialWidth = bitmap.getWidth();\n                double initialHeight = bitmap.getHeight();\n                int width = initialHeight < initialWidth ? maxSize : (int) (initialWidth / initialHeight * maxSize);\n                int height = initialWidth <= initialHeight ? maxSize : (int) (initialHeight / initialWidth * maxSize);\n\n                bitmap = Bitmap.createScaledBitmap(bitmap, width,\n                        height, true);\n            }\n\n            if (rotation != 0) {\n                Matrix mat = new Matrix();\n                mat.postRotate(rotation);\n\n                Bitmap bitmap1 = Bitmap.createBitmap(bitmap, 0, 0, bitmap.getWidth(), bitmap.getHeight(), mat, true);\n                if (bitmap != bitmap1) {\n                    bitmap.recycle();\n                }\n\n                if (cameraFacing == 1) {\n                    Matrix matrixMirror = new Matrix();\n                    matrixMirror.preScale(-1.0f, 1.0f);\n                    Bitmap mirroredBitmap = Bitmap.createBitmap(bitmap1, 0, 0, bitmap1.getWidth(), bitmap1.getHeight(), matrixMirror, true);\n\n                    if (mirroredBitmap != bitmap1) {\n                        bitmap1.recycle();\n                    }\n\n                    imagePath = getSavePhotoLocal(mirroredBitmap);\n\n                    if (mirroredBitmap != null) {\n                        mirroredBitmap.recycle();\n                    }\n                } else {\n                    imagePath = getSavePhotoLocal(bitmap1);\n                    if (bitmap1 != null) {\n                        bitmap1.recycle();\n                    }\n                }\n            } else {\n                if (cameraFacing == 1) {\n                    Matrix matrixMirror = new Matrix();\n                    matrixMirror.preScale(-1.0f, 1.0f);\n                    Bitmap mirroredBitmap = Bitmap.createBitmap(bitmap, 0, 0, bitmap.getWidth(), bitmap.getHeight(), matrixMirror, true);\n\n                    if (mirroredBitmap != bitmap) {\n                        bitmap.recycle();\n                    }\n\n                    imagePath = getSavePhotoLocal(mirroredBitmap);\n\n                    if (mirroredBitmap != null) {\n                        mirroredBitmap.recycle();\n                    }\n                } else {\n                    imagePath = getSavePhotoLocal(bitmap);\n                    if (bitmap != null) {\n                        bitmap.recycle();\n                    }\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return imagePath;\n    }\n\n    private int calculateInSampleSize(BitmapFactory.Options options, int reqWidth, int reqHeight) {\n        final int height = options.outHeight;\n        final int width = options.outWidth;\n        int inSampleSize = 1;\n\n        if (height > reqHeight || width > reqWidth) {\n            if (width > height) {\n                inSampleSize = Math.round((float) height / (float) reqHeight);\n            } else {\n                inSampleSize = Math.round((float) width / (float) reqWidth);\n            }\n        }\n        return inSampleSize;\n    }\n\n    private String getSavePhotoLocal(Bitmap bitmap) {\n        String path = \"\";\n        Date currentTime = Calendar.getInstance().getTime();\n        DateFormat dateFormat = new SimpleDateFormat(\"yyyyMMdd_HHmmss\", Locale.getDefault());\n        try {\n            OutputStream output;\n            File file = new File(folder.getAbsolutePath(), fileNamePrefix + \"_\" + dateFormat.format(currentTime) + \".jpg\");\n            try {\n                output = new FileOutputStream(file);\n                bitmap.compress(Bitmap.CompressFormat.JPEG, 100, output);\n                output.flush();\n                output.close();\n                path = file.getAbsolutePath();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return path;\n    }\n\n    private int getPhotoRotation() {\n        int rotation;\n        int orientation = mPhotoAngle;\n\n        Camera.CameraInfo info = new Camera.CameraInfo();\n        if (cameraFacing == 0) {\n            Camera.getCameraInfo(0, info);\n        } else {\n            Camera.getCameraInfo(1, info);\n        }\n\n        if (info.facing == Camera.CameraInfo.CAMERA_FACING_FRONT) {\n            rotation = (info.orientation - orientation + 360) % 360;\n        } else {\n            rotation = (info.orientation + orientation) % 360;\n        }\n\n        return rotation;\n    }\n\n    private void identifyOrientationEvents() {\n        OrientationEventListener myOrientationEventListener = new OrientationEventListener(context, SensorManager.SENSOR_DELAY_NORMAL) {\n            @Override\n            public void onOrientationChanged(int iAngle) {\n                final int[] iLookup = {0, 0, 0, 90, 90, 90, 90, 90, 90, 180, 180, 180, 180, 180, 180, 270, 270, 270, 270, 270, 270, 0, 0, 0}; // 15-degree increments\n                if (iAngle != ORIENTATION_UNKNOWN) {\n                    int iNewOrientation = iLookup[iAngle / 15];\n                    if (iOrientation != iNewOrientation) {\n                        iOrientation = iNewOrientation;\n                    }\n                    mPhotoAngle = normalize(iAngle);\n                }\n            }\n        };\n\n        if (myOrientationEventListener.canDetectOrientation()) {\n            myOrientationEventListener.enable();\n        }\n    }\n\n    private int normalize(int degrees) {\n        if (degrees > 315 || degrees <= 45) {\n            return 0;\n        }\n\n        if (degrees <= 135) {\n            return 90;\n        }\n\n        if (degrees <= 225) {\n            return 180;\n        }\n\n        return 270;\n    }\n\n\n    private void handleZoom(MotionEvent event, Camera.Parameters params) {\n        int maxZoom = params.getMaxZoom();\n        int zoom = params.getZoom();\n        float newDist = getFingerSpacing(event);\n\n        if (Math.abs(newDist - mDist) < 2) return;\n\n        if (newDist > mDist) {\n            //zoom in\n            if (zoom < maxZoom)\n                zoom++;\n        } else if (newDist < mDist) {\n            //zoom out\n            if (zoom > 0)\n                zoom--;\n        }\n        mDist = newDist;\n        params.setZoom(zoom);\n        camera.setParameters(params);\n    }\n\n    private void handleFocus(MotionEvent event) {\n        int pointerId = event.getPointerId(0);\n        int pointerIndex = event.findPointerIndex(pointerId);\n        // Get the pointer's current position\n\n        int xxw = imgSurface.getHeight();\n        int xxh = imgSurface.getWidth();\n        float x = event.getY(pointerIndex);\n        float y = xxh - event.getX(pointerIndex);\n\n        //cancel previous actions\n        camera.cancelAutoFocus();\n\n        Rect touchRect = new Rect(\n                (int) (x - 100),\n                (int) (y - 100),\n                (int) (x + 100),\n                (int) (y + 100));\n\n        int aboutToBeLeft = touchRect.left;\n        int aboutToBeTop = touchRect.top;\n        int aboutToBeRight = touchRect.right;\n        int aboutToBeBottom = touchRect.bottom;\n\n        if (aboutToBeLeft < 0) {\n            aboutToBeLeft = 0;\n            aboutToBeRight = 200;\n        }\n        if (aboutToBeTop < 0) {\n            aboutToBeTop = 0;\n            aboutToBeBottom = 200;\n        }\n        if (aboutToBeRight > xxw) {\n            aboutToBeRight = xxw;\n            aboutToBeLeft = xxw - 200;\n        }\n        if (aboutToBeBottom > xxh) {\n            aboutToBeBottom = xxh;\n            aboutToBeTop = xxh - 200;\n        }\n\n        aboutToBeLeft = aboutToBeLeft * 2000 / xxw - 1000;\n        aboutToBeTop = aboutToBeTop * 2000 / xxh - 1000;\n        aboutToBeRight = aboutToBeRight * 2000 / xxw - 1000;\n        aboutToBeBottom = aboutToBeBottom * 2000 / xxh - 1000;\n\n        Rect focusRect = new Rect(\n                aboutToBeLeft,\n                aboutToBeTop,\n                aboutToBeRight,\n                aboutToBeBottom);\n\n        Camera.Parameters parameters = null;\n\n        try {\n            parameters = camera.getParameters();\n        } catch (Exception e) {\n            Log.e(\"Error\", \"Error getting parameter:\" + e);\n        }\n\n        // check if parameters are set (handle RuntimeException: getParameters failed (empty parameters))\n        if (parameters != null) {\n            List<Camera.Area> mylist2 = new ArrayList<>();\n\n            mylist2.add(new Camera.Area(focusRect, 1000));\n\n            List<String> supportedFocusMode = parameters.getSupportedFocusModes();\n            String focusMode = Camera.Parameters.FOCUS_MODE_AUTO;\n            if (!supportedFocusMode.contains(Camera.Parameters.FOCUS_MODE_AUTO)) {\n                if (supportedFocusMode.size() > 0) {\n                    focusMode = supportedFocusMode.get(0);\n                }\n            }\n            parameters.setFocusMode(focusMode);\n            if (focusMode == Camera.Parameters.FOCUS_MODE_AUTO)\n                parameters.setFocusAreas(mylist2);\n\n            try {\n                camera.setParameters(parameters);\n                camera.autoFocus(new Camera.AutoFocusCallback() {\n                    @Override\n                    public void onAutoFocus(boolean success, Camera camera) {\n                    }\n                });\n            } catch (Exception e) {\n                Log.e(\"error\", \"cameraerror=> \" + e);\n            }\n        }\n    }\n\n    private float getFingerSpacing(MotionEvent event) {\n        // ...\n        float x = event.getX(0) - event.getX(1);\n        float y = event.getY(0) - event.getY(1);\n        return (float) Math.sqrt(x * x + y * y);\n    }\n\n\n    private static long gcm(long a, long b) {\n        return b == 0 ? a : gcm(b, a % b); // Not bad for one line of code :)\n    }\n\n    private static String asFraction(long a, long b) {\n        long gcm = gcm(a, b);\n        return (a / gcm) + \":\" + (b / gcm);\n    }\n}\n\n\ninterface CustomMultiplePermissionsListener {\n    void onPermissionsChecked(MultiplePermissionsReport report);\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/android/src/main/java/com/search/my_camera/MyCamera.java b/android/src/main/java/com/search/my_camera/MyCamera.java
--- a/android/src/main/java/com/search/my_camera/MyCamera.java	
+++ b/android/src/main/java/com/search/my_camera/MyCamera.java	
@@ -7,6 +7,8 @@
 import androidx.core.app.ActivityCompat;
 import io.flutter.embedding.engine.plugins.FlutterPlugin;
 import io.flutter.embedding.engine.plugins.activity.ActivityAware;
+import io.flutter.embedding.android.FlutterActivity;
+
 import io.flutter.embedding.engine.plugins.activity.ActivityPluginBinding;
 import android.content.Context;
 import android.graphics.Bitmap;
@@ -41,6 +43,7 @@
 import io.flutter.plugin.common.MethodChannel.Result;
 import io.flutter.plugin.common.MethodCall;
 import io.flutter.plugin.common.PluginRegistry;
+
 import io.flutter.plugin.common.PluginRegistry.Registrar;
 
 import com.uuzuche.lib_zxing.activity.CodeUtils;
Index: .idea/my_camera.iml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<module type=\"JAVA_MODULE\" version=\"4\">\n  <component name=\"NewModuleRootManager\" inherit-compiler-output=\"true\">\n    <exclude-output />\n    <content url=\"file://$MODULE_DIR$\">\n      <excludeFolder url=\"file://$MODULE_DIR$/.dart_tool\" />\n      <excludeFolder url=\"file://$MODULE_DIR$/.pub\" />\n      <excludeFolder url=\"file://$MODULE_DIR$/build\" />\n      <excludeFolder url=\"file://$MODULE_DIR$/example/.dart_tool\" />\n      <excludeFolder url=\"file://$MODULE_DIR$/example/.pub\" />\n      <excludeFolder url=\"file://$MODULE_DIR$/example/build\" />\n    </content>\n    <orderEntry type=\"inheritedJdk\" />\n    <orderEntry type=\"sourceFolder\" forTests=\"false\" />\n    <orderEntry type=\"library\" name=\"Dart SDK\" level=\"project\" />\n    <orderEntry type=\"library\" name=\"Flutter Plugins\" level=\"project\" />\n  </component>\n</module>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/my_camera.iml b/.idea/my_camera.iml
--- a/.idea/my_camera.iml	
+++ b/.idea/my_camera.iml	
@@ -9,6 +9,9 @@
       <excludeFolder url="file://$MODULE_DIR$/example/.dart_tool" />
       <excludeFolder url="file://$MODULE_DIR$/example/.pub" />
       <excludeFolder url="file://$MODULE_DIR$/example/build" />
+      <excludeFolder url="file://$MODULE_DIR$/costom_camra_v2/.dart_tool" />
+      <excludeFolder url="file://$MODULE_DIR$/costom_camra_v2/.pub" />
+      <excludeFolder url="file://$MODULE_DIR$/costom_camra_v2/build" />
     </content>
     <orderEntry type="inheritedJdk" />
     <orderEntry type="sourceFolder" forTests="false" />
Index: pubspec.lock
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+># Generated by pub\n# See https://dart.dev/tools/pub/glossary#lockfile\npackages:\n  async:\n    dependency: transitive\n    description:\n      name: async\n      sha256: bfe67ef28df125b7dddcea62755991f807aa39a2492a23e1550161692950bbe0\n      url: \"https://pub.dev\"\n    source: hosted\n    version: \"2.10.0\"\n  boolean_selector:\n    dependency: transitive\n    description:\n      name: boolean_selector\n      sha256: \"6cfb5af12253eaf2b368f07bacc5a80d1301a071c73360d746b7f2e32d762c66\"\n      url: \"https://pub.dev\"\n    source: hosted\n    version: \"2.1.1\"\n  characters:\n    dependency: transitive\n    description:\n      name: characters\n      sha256: e6a326c8af69605aec75ed6c187d06b349707a27fbff8222ca9cc2cff167975c\n      url: \"https://pub.dev\"\n    source: hosted\n    version: \"1.2.1\"\n  clock:\n    dependency: transitive\n    description:\n      name: clock\n      sha256: cb6d7f03e1de671e34607e909a7213e31d7752be4fb66a86d29fe1eb14bfb5cf\n      url: \"https://pub.dev\"\n    source: hosted\n    version: \"1.1.1\"\n  collection:\n    dependency: transitive\n    description:\n      name: collection\n      sha256: cfc915e6923fe5ce6e153b0723c753045de46de1b4d63771530504004a45fae0\n      url: \"https://pub.dev\"\n    source: hosted\n    version: \"1.17.0\"\n  fake_async:\n    dependency: transitive\n    description:\n      name: fake_async\n      sha256: \"511392330127add0b769b75a987850d136345d9227c6b94c96a04cf4a391bf78\"\n      url: \"https://pub.dev\"\n    source: hosted\n    version: \"1.3.1\"\n  flutter:\n    dependency: \"direct main\"\n    description: flutter\n    source: sdk\n    version: \"0.0.0\"\n  flutter_test:\n    dependency: \"direct dev\"\n    description: flutter\n    source: sdk\n    version: \"0.0.0\"\n  js:\n    dependency: transitive\n    description:\n      name: js\n      sha256: \"5528c2f391ededb7775ec1daa69e65a2d61276f7552de2b5f7b8d34ee9fd4ab7\"\n      url: \"https://pub.dev\"\n    source: hosted\n    version: \"0.6.5\"\n  matcher:\n    dependency: transitive\n    description:\n      name: matcher\n      sha256: \"16db949ceee371e9b99d22f88fa3a73c4e59fd0afed0bd25fc336eb76c198b72\"\n      url: \"https://pub.dev\"\n    source: hosted\n    version: \"0.12.13\"\n  material_color_utilities:\n    dependency: transitive\n    description:\n      name: material_color_utilities\n      sha256: d92141dc6fe1dad30722f9aa826c7fbc896d021d792f80678280601aff8cf724\n      url: \"https://pub.dev\"\n    source: hosted\n    version: \"0.2.0\"\n  meta:\n    dependency: transitive\n    description:\n      name: meta\n      sha256: \"6c268b42ed578a53088d834796959e4a1814b5e9e164f147f580a386e5decf42\"\n      url: \"https://pub.dev\"\n    source: hosted\n    version: \"1.8.0\"\n  path:\n    dependency: transitive\n    description:\n      name: path\n      sha256: db9d4f58c908a4ba5953fcee2ae317c94889433e5024c27ce74a37f94267945b\n      url: \"https://pub.dev\"\n    source: hosted\n    version: \"1.8.2\"\n  sky_engine:\n    dependency: transitive\n    description: flutter\n    source: sdk\n    version: \"0.0.99\"\n  source_span:\n    dependency: transitive\n    description:\n      name: source_span\n      sha256: dd904f795d4b4f3b870833847c461801f6750a9fa8e61ea5ac53f9422b31f250\n      url: \"https://pub.dev\"\n    source: hosted\n    version: \"1.9.1\"\n  stack_trace:\n    dependency: transitive\n    description:\n      name: stack_trace\n      sha256: c3c7d8edb15bee7f0f74debd4b9c5f3c2ea86766fe4178eb2a18eb30a0bdaed5\n      url: \"https://pub.dev\"\n    source: hosted\n    version: \"1.11.0\"\n  stream_channel:\n    dependency: transitive\n    description:\n      name: stream_channel\n      sha256: \"83615bee9045c1d322bbbd1ba209b7a749c2cbcdcb3fdd1df8eb488b3279c1c8\"\n      url: \"https://pub.dev\"\n    source: hosted\n    version: \"2.1.1\"\n  string_scanner:\n    dependency: transitive\n    description:\n      name: string_scanner\n      sha256: \"556692adab6cfa87322a115640c11f13cb77b3f076ddcc5d6ae3c20242bedcde\"\n      url: \"https://pub.dev\"\n    source: hosted\n    version: \"1.2.0\"\n  term_glyph:\n    dependency: transitive\n    description:\n      name: term_glyph\n      sha256: a29248a84fbb7c79282b40b8c72a1209db169a2e0542bce341da992fe1bc7e84\n      url: \"https://pub.dev\"\n    source: hosted\n    version: \"1.2.1\"\n  test_api:\n    dependency: transitive\n    description:\n      name: test_api\n      sha256: ad540f65f92caa91bf21dfc8ffb8c589d6e4dc0c2267818b4cc2792857706206\n      url: \"https://pub.dev\"\n    source: hosted\n    version: \"0.4.16\"\n  vector_math:\n    dependency: transitive\n    description:\n      name: vector_math\n      sha256: \"80b3257d1492ce4d091729e3a67a60407d227c27241d6927be0130c98e741803\"\n      url: \"https://pub.dev\"\n    source: hosted\n    version: \"2.1.4\"\nsdks:\n  dart: \">=2.19.5 <3.0.0\"\n  flutter: \">=1.20.0\"\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/pubspec.lock b/pubspec.lock
--- a/pubspec.lock	
+++ b/pubspec.lock	
@@ -1,6 +1,30 @@
 # Generated by pub
 # See https://dart.dev/tools/pub/glossary#lockfile
 packages:
+  _fe_analyzer_shared:
+    dependency: transitive
+    description:
+      name: _fe_analyzer_shared
+      sha256: "8880b4cfe7b5b17d57c052a5a3a8cc1d4f546261c7cc8fbd717bd53f48db0568"
+      url: "https://pub.dev"
+    source: hosted
+    version: "59.0.0"
+  analyzer:
+    dependency: transitive
+    description:
+      name: analyzer
+      sha256: a89627f49b0e70e068130a36571409726b04dab12da7e5625941d2c8ec278b96
+      url: "https://pub.dev"
+    source: hosted
+    version: "5.11.1"
+  args:
+    dependency: transitive
+    description:
+      name: args
+      sha256: "4cab82a83ffef80b262ddedf47a0a8e56ee6fbf7fe21e6e768b02792034dd440"
+      url: "https://pub.dev"
+    source: hosted
+    version: "2.4.0"
   async:
     dependency: transitive
     description:
@@ -41,6 +65,30 @@
       url: "https://pub.dev"
     source: hosted
     version: "1.17.0"
+  convert:
+    dependency: transitive
+    description:
+      name: convert
+      sha256: "0f08b14755d163f6e2134cb58222dd25ea2a2ee8a195e53983d57c075324d592"
+      url: "https://pub.dev"
+    source: hosted
+    version: "3.1.1"
+  coverage:
+    dependency: transitive
+    description:
+      name: coverage
+      sha256: "2fb815080e44a09b85e0f2ca8a820b15053982b2e714b59267719e8a9ff17097"
+      url: "https://pub.dev"
+    source: hosted
+    version: "1.6.3"
+  crypto:
+    dependency: transitive
+    description:
+      name: crypto
+      sha256: aa274aa7774f8964e4f4f38cc994db7b6158dd36e9187aaceaddc994b35c6c67
+      url: "https://pub.dev"
+    source: hosted
+    version: "3.0.2"
   fake_async:
     dependency: transitive
     description:
@@ -49,6 +97,14 @@
       url: "https://pub.dev"
     source: hosted
     version: "1.3.1"
+  file:
+    dependency: transitive
+    description:
+      name: file
+      sha256: "1b92bec4fc2a72f59a8e15af5f52cd441e4a7860b49499d69dfa817af20e925d"
+      url: "https://pub.dev"
+    source: hosted
+    version: "6.1.4"
   flutter:
     dependency: "direct main"
     description: flutter
@@ -59,6 +115,46 @@
     description: flutter
     source: sdk
     version: "0.0.0"
+  frontend_server_client:
+    dependency: transitive
+    description:
+      name: frontend_server_client
+      sha256: "408e3ca148b31c20282ad6f37ebfa6f4bdc8fede5b74bc2f08d9d92b55db3612"
+      url: "https://pub.dev"
+    source: hosted
+    version: "3.2.0"
+  glob:
+    dependency: transitive
+    description:
+      name: glob
+      sha256: "4515b5b6ddb505ebdd242a5f2cc5d22d3d6a80013789debfbda7777f47ea308c"
+      url: "https://pub.dev"
+    source: hosted
+    version: "2.1.1"
+  http_multi_server:
+    dependency: transitive
+    description:
+      name: http_multi_server
+      sha256: "97486f20f9c2f7be8f514851703d0119c3596d14ea63227af6f7a481ef2b2f8b"
+      url: "https://pub.dev"
+    source: hosted
+    version: "3.2.1"
+  http_parser:
+    dependency: transitive
+    description:
+      name: http_parser
+      sha256: "2aa08ce0341cc9b354a498388e30986515406668dbcc4f7c950c3e715496693b"
+      url: "https://pub.dev"
+    source: hosted
+    version: "4.0.2"
+  io:
+    dependency: transitive
+    description:
+      name: io
+      sha256: "2ec25704aba361659e10e3e5f5d672068d332fc8ac516421d483a11e5cbd061e"
+      url: "https://pub.dev"
+    source: hosted
+    version: "1.0.4"
   js:
     dependency: transitive
     description:
@@ -67,6 +163,14 @@
       url: "https://pub.dev"
     source: hosted
     version: "0.6.5"
+  logging:
+    dependency: transitive
+    description:
+      name: logging
+      sha256: "04094f2eb032cbb06c6f6e8d3607edcfcb0455e2bb6cbc010cb01171dcb64e6d"
+      url: "https://pub.dev"
+    source: hosted
+    version: "1.1.1"
   matcher:
     dependency: transitive
     description:
@@ -91,6 +195,30 @@
       url: "https://pub.dev"
     source: hosted
     version: "1.8.0"
+  mime:
+    dependency: transitive
+    description:
+      name: mime
+      sha256: e4ff8e8564c03f255408decd16e7899da1733852a9110a58fe6d1b817684a63e
+      url: "https://pub.dev"
+    source: hosted
+    version: "1.0.4"
+  node_preamble:
+    dependency: transitive
+    description:
+      name: node_preamble
+      sha256: "6e7eac89047ab8a8d26cf16127b5ed26de65209847630400f9aefd7cd5c730db"
+      url: "https://pub.dev"
+    source: hosted
+    version: "2.0.2"
+  package_config:
+    dependency: transitive
+    description:
+      name: package_config
+      sha256: "1c5b77ccc91e4823a5af61ee74e6b972db1ef98c2ff5a18d3161c982a55448bd"
+      url: "https://pub.dev"
+    source: hosted
+    version: "2.1.0"
   path:
     dependency: transitive
     description:
@@ -99,11 +227,75 @@
       url: "https://pub.dev"
     source: hosted
     version: "1.8.2"
+  pool:
+    dependency: transitive
+    description:
+      name: pool
+      sha256: "20fe868b6314b322ea036ba325e6fc0711a22948856475e2c2b6306e8ab39c2a"
+      url: "https://pub.dev"
+    source: hosted
+    version: "1.5.1"
+  pub_semver:
+    dependency: transitive
+    description:
+      name: pub_semver
+      sha256: "307de764d305289ff24ad257ad5c5793ce56d04947599ad68b3baa124105fc17"
+      url: "https://pub.dev"
+    source: hosted
+    version: "2.1.3"
+  shelf:
+    dependency: transitive
+    description:
+      name: shelf
+      sha256: c24a96135a2ccd62c64b69315a14adc5c3419df63b4d7c05832a346fdb73682c
+      url: "https://pub.dev"
+    source: hosted
+    version: "1.4.0"
+  shelf_packages_handler:
+    dependency: transitive
+    description:
+      name: shelf_packages_handler
+      sha256: aef74dc9195746a384843102142ab65b6a4735bb3beea791e63527b88cc83306
+      url: "https://pub.dev"
+    source: hosted
+    version: "3.0.1"
+  shelf_static:
+    dependency: transitive
+    description:
+      name: shelf_static
+      sha256: e792b76b96a36d4a41b819da593aff4bdd413576b3ba6150df5d8d9996d2e74c
+      url: "https://pub.dev"
+    source: hosted
+    version: "1.1.1"
+  shelf_web_socket:
+    dependency: transitive
+    description:
+      name: shelf_web_socket
+      sha256: a988c0e8d8ffbdb8a28aa7ec8e449c260f3deb808781fe1284d22c5bba7156e8
+      url: "https://pub.dev"
+    source: hosted
+    version: "1.0.3"
   sky_engine:
     dependency: transitive
     description: flutter
     source: sdk
     version: "0.0.99"
+  source_map_stack_trace:
+    dependency: transitive
+    description:
+      name: source_map_stack_trace
+      sha256: "84cf769ad83aa6bb61e0aa5a18e53aea683395f196a6f39c4c881fb90ed4f7ae"
+      url: "https://pub.dev"
+    source: hosted
+    version: "2.1.1"
+  source_maps:
+    dependency: transitive
+    description:
+      name: source_maps
+      sha256: "708b3f6b97248e5781f493b765c3337db11c5d2c81c3094f10904bfa8004c703"
+      url: "https://pub.dev"
+    source: hosted
+    version: "0.10.12"
   source_span:
     dependency: transitive
     description:
@@ -144,6 +336,14 @@
       url: "https://pub.dev"
     source: hosted
     version: "1.2.1"
+  test:
+    dependency: "direct dev"
+    description:
+      name: test
+      sha256: a5fcd2d25eeadbb6589e80198a47d6a464ba3e2049da473943b8af9797900c2d
+      url: "https://pub.dev"
+    source: hosted
+    version: "1.22.0"
   test_api:
     dependency: transitive
     description:
@@ -152,6 +352,22 @@
       url: "https://pub.dev"
     source: hosted
     version: "0.4.16"
+  test_core:
+    dependency: transitive
+    description:
+      name: test_core
+      sha256: "0ef9755ec6d746951ba0aabe62f874b707690b5ede0fecc818b138fcc9b14888"
+      url: "https://pub.dev"
+    source: hosted
+    version: "0.4.20"
+  typed_data:
+    dependency: transitive
+    description:
+      name: typed_data
+      sha256: "26f87ade979c47a150c9eaab93ccd2bebe70a27dc0b4b29517f2904f04eb11a5"
+      url: "https://pub.dev"
+    source: hosted
+    version: "1.3.1"
   vector_math:
     dependency: transitive
     description:
@@ -160,6 +376,46 @@
       url: "https://pub.dev"
     source: hosted
     version: "2.1.4"
+  vm_service:
+    dependency: transitive
+    description:
+      name: vm_service
+      sha256: e7fb6c2282f7631712b69c19d1bff82f3767eea33a2321c14fa59ad67ea391c7
+      url: "https://pub.dev"
+    source: hosted
+    version: "9.4.0"
+  watcher:
+    dependency: transitive
+    description:
+      name: watcher
+      sha256: "6a7f46926b01ce81bfc339da6a7f20afbe7733eff9846f6d6a5466aa4c6667c0"
+      url: "https://pub.dev"
+    source: hosted
+    version: "1.0.2"
+  web_socket_channel:
+    dependency: transitive
+    description:
+      name: web_socket_channel
+      sha256: d88238e5eac9a42bb43ca4e721edba3c08c6354d4a53063afaa568516217621b
+      url: "https://pub.dev"
+    source: hosted
+    version: "2.4.0"
+  webkit_inspection_protocol:
+    dependency: transitive
+    description:
+      name: webkit_inspection_protocol
+      sha256: "67d3a8b6c79e1987d19d848b0892e582dbb0c66c57cc1fef58a177dd2aa2823d"
+      url: "https://pub.dev"
+    source: hosted
+    version: "1.2.0"
+  yaml:
+    dependency: transitive
+    description:
+      name: yaml
+      sha256: "23812a9b125b48d4007117254bca50abb6c712352927eece9e155207b1db2370"
+      url: "https://pub.dev"
+    source: hosted
+    version: "3.1.1"
 sdks:
   dart: ">=2.19.5 <3.0.0"
   flutter: ">=1.20.0"
